<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-max-osx.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hello" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Write Something I Want">
<meta property="og:type" content="website">
<meta property="og:title" content="Air Little Place">
<meta property="og:url" content="http://air.com/page/2/index.html">
<meta property="og:site_name" content="Air Little Place">
<meta property="og:description" content="Write Something I Want">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Air Little Place">
<meta name="twitter:description" content="Write Something I Want">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>







  <title>Air Little Place</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-103683322-1', 'auto');
  ga('send', 'pageview');
</script>












  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Air Little Place</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://air.com/2017/03/01/Groovy&Gradle入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Air">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Air Little Place">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/01/Groovy&Gradle入门/" itemprop="url">Groovy & Gradle 入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-01T00:00:00+08:00">
                2017-03-01
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/01/Groovy&Gradle入门/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/03/01/Groovy&Gradle入门/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Groovy"><a href="#Groovy" class="headerlink" title="Groovy"></a>Groovy</h2><p><strong>Groovy的API文档位于 <a href="http://www.groovy-lang.org/api.html" target="_blank" rel="external">http://www.groovy-lang.org/api.html</a></strong></p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ol>
<li>单引号’’中的内容严格对应Java中的String，不对$符号进行转义</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> singleQuote=<span class="string">'I am $ dolloar'</span>  <span class="comment">//输出就是I am $ dolloar</span></div></pre></td></tr></table></figure>
<ol>
<li>双引号””的内容则和脚本语言的处理有点像，如果字符中有<em>$</em>符的话，则它会<strong>$表达式</strong>先求值。</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> doubleQuoteWithoutDollar = <span class="string">"I am one dollar"</span> <span class="comment">//输出 I am one dollar</span></div><div class="line"><span class="keyword">def</span> x = <span class="number">1</span></div><div class="line"><span class="keyword">def</span> doubleQuoteWithDollar = <span class="string">"I am $x dolloar"</span> <span class="comment">//输出I am 1 dolloar</span></div></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>调用的时候可以不加括号</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">println(<span class="string">"test"</span>) ----&gt;  println <span class="string">"test"</span></div></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> getString()&#123;</div><div class="line">	<span class="comment">//代码的最后一句是返回值</span></div><div class="line">  <span class="string">"Hello World!"</span></div><div class="line">  <span class="comment">// 也可以使用return，和Java中普通函数一样</span></div><div class="line">	<span class="comment">// return "Hello World!"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="闭包-Closure"><a href="#闭包-Closure" class="headerlink" title="闭包(Closure)"></a>闭包(Closure)</h3><p>是一种数据类型，它代表了一段可执行的代码（类比Java的匿名内部类，可以被称为匿名函数）。其外形如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> closure = &#123;<span class="comment">//闭包是一段代码，所以需要用花括号括起来..</span></div><div class="line">    String param1, <span class="keyword">int</span> param2</div><div class="line">    -&gt;  <span class="comment">//这个箭头很关键。箭头前面是参数定义，箭头后面是代码</span></div><div class="line">    println <span class="string">"this is codes, $param1, $param2"</span> <span class="comment">//这是代码，最后一句是返回值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简而言之，Closure的定义格式是：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> closure = &#123;params -&gt; codes&#125;  <span class="comment">// or</span></div><div class="line"><span class="keyword">def</span> closure = &#123;codes&#125;  <span class="comment">// no params ,so  no '-&gt;'</span></div></pre></td></tr></table></figure>
<p>闭包定义好后，要调用它的方法就是：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">closure.call(params) </div><div class="line"><span class="comment">// 下面的方式也可以（groovy 的语法糖）</span></div><div class="line">closure(params)</div></pre></td></tr></table></figure>
<p><strong>如果闭包没定义参数的话，则隐含有一个参数，这个参数名字叫it，和this的作用类似。it代表闭包的参数。</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> greeting = &#123; <span class="string">"Hello, $it!"</span> &#125;</div><div class="line"><span class="keyword">assert</span> greeting(<span class="string">'XiaoKa'</span>) == <span class="string">'Hello, XiaoKa!'</span></div></pre></td></tr></table></figure>
<p><strong>Groovy中，调用函数时可以省略圆括号，当然，对于函数的参数里包含闭包同样适用。</strong></p>
<p>比如对于下面这个方法</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; each(List&lt;T&gt; self, Closure closure)</div></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 就可以如下方式调用</span></div><div class="line"><span class="keyword">def</span> testList = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]  <span class="comment">//定义一个List</span></div><div class="line">testList.each &#123;</div><div class="line">  println it</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个地方要记得，对于看gradle的代码很有帮助</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">doLast&#123;</div><div class="line">  println <span class="string">'Hello World!'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码应该是</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">doLast(&#123;</div><div class="line">  println <span class="string">'Hello World!'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="Gradle-基于3-2-1版本"><a href="#Gradle-基于3-2-1版本" class="headerlink" title="Gradle (基于3.2.1版本)"></a>Gradle (基于3.2.1版本)</h2><p>Gradle是什么:</p>
<p><strong>Gradle是一个框架，作为框架，它负责定义流程和规则。而具体的编译工作则是通过插件(Plugin)的方式来完成的。</strong></p>
<h3 id="Gradle工作流程"><a href="#Gradle工作流程" class="headerlink" title="Gradle工作流程"></a>Gradle工作流程</h3><p><img src="/img/gradle/gradle.png" alt="img"></p>
<p>可以看出，Gradle工作包含三个阶段：</p>
<ul>
<li>首先是初始化阶段(Initiliazation phase):对Android项目而言，就是evaluate <code>settings.gradle</code>，并将每个Project内的build.gradle转化为Project对象。</li>
<li>Configration阶段:配置对应的Project对象，<code>build.gradle</code>中有关build的代码将会被执行。Configuration阶段完了后，整个build的project以及内部的Task关系就确定了。Configuration会建立一个有向图来描述Task之间的依赖关系。</li>
<li>最后一个阶段就是执行阶段: 我们可以通过给<code>gradle</code>传递相应的命令来执行相应的task。</li>
</ul>
<h3 id="写Gradle代码"><a href="#写Gradle代码" class="headerlink" title="写Gradle代码"></a>写Gradle代码</h3><p>Gradle dsl api 文档: <a href="https://docs.gradle.org/current/dsl/" target="_blank" rel="external">https://docs.gradle.org/current/dsl/</a></p>
<p>Gradle基于Groovy，Groovy又基于Java。所以，Gradle执行的时候和Groovy一样，会把脚本转换成Java对象。<br>Gradle主要有三种对象，这三种对象和三种不同的脚本文件对应，在gradle执行的时候，会将脚本转换成对应的对象：</p>
<ul>
<li>Gradle对象：当我们执行gradle xxx或者什么的时候，gradle会从默认的配置脚本中构造出一个Gradle对象。在整个执行过程中，只有这么一个对象。Gradle对象的数据类型就是Gradle。我们一般很少去定制这个默认的配置脚本。</li>
<li>Project对象：每一个build.gradle会转换成一个Project对象。</li>
<li>Settings对象：显然，每一个settings.gradle都会转换成一个Settings对象。</li>
</ul>
<p>当我们执行gradle的时候，gradle首先是按顺序解析各个gradle文件。这里边就有所谓的顺序问题。这里看一下下面的文档，里面提到的生命周期就是说明这个顺序的。</p>
<p><strong>Lifecycle</strong></p>
<p>There is a one-to-one relationship between a Project and a build.gradle file. During build initialisation, Gradle assembles a Project object for each project which is to participate in the build, as follows:</p>
<ul>
<li>Create a <a href="https://docs.gradle.org/current/dsl/org.gradle.api.initialization.Settings.html" target="_blank" rel="external"><code>Settings</code></a> instance for the build.</li>
<li>Evaluate the settings.gradle script, if present, against the <a href="https://docs.gradle.org/current/dsl/org.gradle.api.initialization.Settings.html" target="_blank" rel="external"><code>Settings</code></a> object to configure it.</li>
<li>Use the configured <a href="https://docs.gradle.org/current/dsl/org.gradle.api.initialization.Settings.html" target="_blank" rel="external"><code>Settings</code></a> object to create the hierarchy of Project instances.</li>
<li>Finally, evaluate each Project by executing its build.gradle file, if present, against the project. The projects are evaluated in breadth-wise order, such that a project is evaluated before its child projects. This order can be overridden by calling <code>Project.evaluationDependsOnChildren()</code> or by adding an explicit evaluation dependency using <code>Project.evaluationDependsOn(java.lang.String).</code></li>
</ul>
<p>Project和<code>build.gradle</code>文件是一一对应的。在build初始化阶段，Gradle为每一个参与Build的project创建一个<code>Project</code>对象。</p>
<ul>
<li>为此次build创建一个<code>Settings</code>实例</li>
<li>Evaluate <code>settings.gradle</code>脚本，如果存在，修改前面<code>Settings</code>实例的属性</li>
<li>根据前面配置过的<code>Settings</code>实例创建<code>Project</code>实例的关系图</li>
<li>最后，通过执行它的<code>build.gradle</code>文件来evaluate每个Project。这个evaluate按照广度优先的顺序，这样可以让子Project在父Project之后evaluate。这个顺序也可以修改。</li>
</ul>
<h4 id="Project对象"><a href="#Project对象" class="headerlink" title="Project对象"></a>Project对象</h4><p>每一个build.gradle文件都会转换成一个Project对象。在Gradle术语中，Project对象对应的是<strong>Build Script</strong>。</p>
<p><strong>Build scripts are code</strong></p>
<p>Project包含若干Tasks。另外，由于Project对应具体的工程，所以需要为Project加载所需要的插件(<code>apply plugin: &#39;xxx&#39;</code>)。其实，一个Project包含多少Task往往是插件决定的。</p>
<p>所以，在Project中，我们要:</p>
<ul>
<li>加载插件。</li>
<li>配置插件的行为，就相当于设置配置文件</li>
</ul>
<p>Project API 文档: </p>
<p><strong><a href="https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html" target="_blank" rel="external">https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html</a></strong></p>
<ol>
<li>加载插件</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.library'</span>    &lt;==如果是编译Library，则加载此插件</div><div class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span>  &lt;==如果是编译Android APP，则加载此插件</div></pre></td></tr></table></figure>
<p>这是每个Android项目都会见到的代码，这个代码调用<code>apply</code>函数，看一下上面的文档，在<code>Method Summary</code>最底部才能看到<code>apply</code>函数，原来是继承自<code>PluginAware</code>接口。</p>
<p><img src="/img/gradle/apply.png" alt="PluginAware apply方法"></p>
<p>那么，上面那个<code>apply</code>方法是上图所示的第几个方法呢？点击查看详细情况，发现第三个<code>apply</code>函数的解释是:</p>
<p>The following options are available:</p>
<ul>
<li>from: A script to apply. Accepts any path supported by Project.uri(Object).</li>
<li>plugin: The id or implementation class of the plugin to apply.</li>
<li>to: The target delegate object or objects. The default is this plugin aware object. Use this to configure objects other than this object.</li>
</ul>
<p>除了最常见的<code>apply plugin: &#39;xxx&#39;</code>,我们经常使用的<code>apply from: &#39;xxx&#39;</code>也在此。</p>
<p><code>apply plugin: &#39;xxx&#39;</code>加载二进制插件，也就是把对应的jar包下载到了本地。至于我们使用的<code>apply from: &#39;xxx&#39;</code>就是加载对应的文件。</p>
<ol>
<li>配置属性</li>
</ol>
<p>这一点大家只要去看对应plugin的文档即可，文档内提到有哪些属性，则就可以配置哪些属性。</p>
<p>Gradle官方提供的plugin都可以在这里找到对应的文档（比如我们日常用的plugin: ‘maven’）<br><strong><a href="https://docs.gradle.org/current/userguide/userguide.html" target="_blank" rel="external">https://docs.gradle.org/current/userguide/userguide.html</a></strong></p>
<p>Android library和application文档见:<br><strong><a href="http://google.github.io/android-gradle-dsl/current/index.html" target="_blank" rel="external">http://google.github.io/android-gradle-dsl/current/index.html</a></strong></p>
<p>其他的第三方plugin,则直接找他们的文档即可。</p>
<p>Project 的一些其它说明:</p>
<h5 id="Extra-属性"><a href="#Extra-属性" class="headerlink" title="Extra 属性"></a>Extra 属性</h5><p>所有额外的属性都需要通过命名空间<code>ext</code>来定义。一旦额外属性被定义了，它可以被所属对象直接访问(读写)(在Project中定义的话，就可以在Project，Task和子Project中访问了)<br>只有初始声明的时候需要命名空间。(当然，如果和其它属性重名还需要全称来指定)</p>
<p>All extra properties must be defined through the <code>ext</code> namespace. Once an extra property has been defined,<br>it is available directly on the owning object (in the below case the Project, Task, and sub-projects respectively) and<br>can be read and updated. Only the initial declaration that needs to be done via the namespace.</p>
<p>最后就是查找顺序，放在这里供大家参考，就不翻译了。</p>
<h5 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h5><p>A project has 5 property ‘scopes’, which it searches for properties. You can access these properties by name in your build file, or by calling the project’s Project.property(java.lang.String) method. The scopes are:</p>
<ul>
<li>The <code>Project</code> object itself. This scope includes any property getters and setters declared by the Project implementation class. For example, Project.getRootProject() is accessible as the rootProject property. The properties of this scope are readable or writable depending on the presence of the corresponding getter or setter method.</li>
<li>The <code>extra</code> properties of the project. Each project maintains a map of extra properties, which can contain any arbitrary name -&gt; value pair. Once defined, the properties of this scope are readable and writable. See extra properties for more details.</li>
<li>The <code>extensions</code> added to the project by the plugins. Each extension is available as a read-only property with the same name as the extension.</li>
<li>The <code>convention</code> properties added to the project by the plugins. A plugin can add properties and methods to a project through the project’s Convention object. The properties of this scope may be readable or writable, depending on the convention objects.</li>
<li>The tasks of the project. A task is accessible by using its name as a property name. The properties of this scope are read-only. For example, a task called compile is accessible as the compile property.</li>
<li>The extra properties and convention properties inherited from the project’s parent, recursively up to the root project. The properties of this scope are read-only.<br>When reading a property, the project searches the above scopes in order, and returns the value from the first scope it finds the property in. If not found, an exception is thrown. See Project.property(java.lang.String) for more details.</li>
</ul>
<p>When writing a property, the project searches the above scopes in order, and sets the property in the first scope it finds the property in. If not found, an exception is thrown. See Project.setProperty(java.lang.String, java.lang.Object) for more details.</p>
<h5 id="Dynamic-Methods"><a href="#Dynamic-Methods" class="headerlink" title="Dynamic Methods"></a>Dynamic Methods</h5><p>A project has 5 method ‘scopes’, which it searches for methods:</p>
<ul>
<li>The <code>Project</code> object itself.</li>
<li>The build file. The project searches for a matching method declared in the build file.</li>
<li>The <code>extensions</code> added to the project by the plugins. Each extension is available as a method which takes a closure or Action as a parameter.</li>
<li>The <code>convention</code> methods added to the project by the plugins. A plugin can add properties and method to a project through the project’s Convention object.</li>
<li>The tasks of the project. A method is added for each task, using the name of the task as the method name and taking a single closure or Action parameter. The method calls the Task.configure(groovy.lang.Closure) method for the associated task with the provided closure. For example, if the project has a task called compile, then a method is added with the following signature: void compile(Closure configureClosure).</li>
<li>The methods of the parent project, recursively up to the root project.</li>
<li>A property of the project whose value is a closure. The closure is treated as a method and called with the provided parameters. The property is located as described above.</li>
</ul>
<p>参考: <a href="http://blog.csdn.net/innost/article/details/48228651" target="_blank" rel="external">深入理解Android之Gradle</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://air.com/2016/12/10/OkHttp源码解析-(下)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Air">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Air Little Place">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/10/OkHttp源码解析-(下)/" itemprop="url">OkHttp源码解析-(下)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-10T00:00:00+08:00">
                2016-12-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/10/OkHttp源码解析-(下)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2016/12/10/OkHttp源码解析-(下)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇的主要内容就是解析这一个个拦截器，所以重新将图放在这里。</p>
<p><img src="/img/okhttp/OkHttp3.4.1-interceptors.jpg" alt=""></p>
<p>图中存在用户自定义的<code>Interceptor</code>对象，这一部分我们忽略，剩下的<code>Interceptor</code>对象还有如下几个：</p>
<ol>
<li>RetryAndFollowUpInterceptor: 失败重试以及重定向</li>
<li>BridgeInterceptor: 用户友好代码和网络友好代码之间的转化。</li>
<li>CacheInterceptor: 读取缓存直接返回、更新缓存</li>
<li>ConnectInterceptor: 和服务器建立连接</li>
<li>CallServerInterceptor: 向服务器发送请求数据、从服务器读取响应数据的</li>
</ol>
<p>第一个分析<code>RetryAndFollowUpInterceptor</code>这个<code>Interceptor</code>对象。</p>
<h3 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h3><p>作为网络框架，意外不可避免，尤其是外部环境导致的意外，这个时候要有合理的恢复策略，同时在HTTP的世界中，还存在服务端修改了域名，旧的域名要通过重定向访问到新的域名的情况。对于框架来说，异常和重定向都是需要重新请求网络的，就在这个拦截器都给处理了。</p>
<h4 id="interceptor"><a href="#interceptor" class="headerlink" title="interceptor()"></a>interceptor()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  Request request = chain.request();</div><div class="line"></div><div class="line">  streamAllocation = <span class="keyword">new</span> StreamAllocation(</div><div class="line">      client.connectionPool(), createAddress(request.url()), callStackTrace);</div><div class="line"></div><div class="line">  <span class="keyword">int</span> followUpCount = <span class="number">0</span>;</div><div class="line">  Response priorResponse = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (canceled) &#123;</div><div class="line">      streamAllocation.release();</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Response response = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">boolean</span> releaseConnection = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">      releaseConnection = <span class="keyword">false</span>;</div><div class="line">    &#125; <span class="keyword">catch</span> (RouteException e) &#123;</div><div class="line">      <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></div><div class="line">      <span class="keyword">if</span> (!recover(e.getLastConnectException(), <span class="keyword">false</span>, request)) &#123;</div><div class="line">        <span class="keyword">throw</span> e.getLastConnectException();</div><div class="line">      &#125;</div><div class="line">      releaseConnection = <span class="keyword">false</span>;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">      <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></div><div class="line">      <span class="keyword">boolean</span> requestSendStarted = !(e <span class="keyword">instanceof</span> ConnectionShutdownException);</div><div class="line">      <span class="keyword">if</span> (!recover(e, requestSendStarted, request)) <span class="keyword">throw</span> e;</div><div class="line">      releaseConnection = <span class="keyword">false</span>;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      <span class="comment">// We're throwing an unchecked exception. Release any resources.</span></div><div class="line">      <span class="keyword">if</span> (releaseConnection) &#123;</div><div class="line">        streamAllocation.streamFailed(<span class="keyword">null</span>);</div><div class="line">        streamAllocation.release();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Attach the prior response if it exists. Such responses never have a body.</span></div><div class="line">    <span class="keyword">if</span> (priorResponse != <span class="keyword">null</span>) &#123;</div><div class="line">      response = response.newBuilder()</div><div class="line">          .priorResponse(priorResponse.newBuilder()</div><div class="line">                  .body(<span class="keyword">null</span>)</div><div class="line">                  .build())</div><div class="line">          .build();</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">    <span class="comment">// 将服务端返回的消息转换为新的Request</span></div><div class="line">    <span class="comment">// 比如服务端返回301，会在Header头有Location字段告诉你要跳转到哪里。</span></div><div class="line">    Request followUp = followUpRequest(response); </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (!forWebSocket) &#123;</div><div class="line">        streamAllocation.release();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> response;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    closeQuietly(response.body());</div><div class="line">	<span class="comment">// 不会无限的重定向跟踪，防止环形重定向或者造成攻击</span></div><div class="line">    <span class="comment">// MAX_FOLLOW_UPS的次数是20</span></div><div class="line">    <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</div><div class="line">      streamAllocation.release();</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Too many follow-up requests: "</span> + followUpCount);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (followUp.body() <span class="keyword">instanceof</span> UnrepeatableRequestBody) &#123;</div><div class="line">      streamAllocation.release();</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HttpRetryException(<span class="string">"Cannot retry streamed HTTP body"</span>, response.code());</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">    <span class="keyword">if</span> (!sameConnection(response, followUp.url())) &#123;</div><div class="line">      streamAllocation.release();</div><div class="line">      streamAllocation = <span class="keyword">new</span> StreamAllocation(</div><div class="line">          client.connectionPool(), createAddress(followUp.url()), callStackTrace);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (streamAllocation.codec() != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Closing the body of "</span> + response</div><div class="line">          + <span class="string">" didn't close its backing stream. Bad interceptor?"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    request = followUp;</div><div class="line">    priorResponse = response;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先构造了<code>StreamAllocation</code>对象，该对象将三个实体的关系联系起来了。分别是</p>
<ul>
<li>Connections: 物理socket链接到远端服务 </li>
<li>Streams: 逻辑上的HTTP request/response对，在Connections层之上。</li>
<li>Calls: 逻辑上的流的序列，通常是一个初始请求和接下来的跳转请求。</li>
</ul>
<p>然后，尝试从服务端获取请求，获取请求之后处理请求，通过<code>followUpRequest()</code>方法，这个方法是这个拦截器处理的核心。如果获取响应失败，则会尝试恢复请求，这个处理内容在<code>recover()</code>方法内，其他的一些错误处理我这里就不解析了。那我们来看一看<code>followUpRequest()</code>方法。</p>
<h4 id="followUpRequest"><a href="#followUpRequest" class="headerlink" title="followUpRequest()"></a>followUpRequest()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Figures out the HTTP request to make in response to receiving &#123;<span class="doctag">@code</span> userResponse&#125;. This will</div><div class="line"> * either add authentication headers, follow redirects or handle a client request timeout. If a</div><div class="line"> * follow-up is either unnecessary or not applicable, this returns null.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">followUpRequest</span><span class="params">(Response userResponse)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  <span class="keyword">if</span> (userResponse == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">  Connection connection = streamAllocation.connection();</div><div class="line">  Route route = connection != <span class="keyword">null</span></div><div class="line">      ? connection.route()</div><div class="line">      : <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">int</span> responseCode = userResponse.code();</div><div class="line"></div><div class="line">  <span class="keyword">final</span> String method = userResponse.request().method();</div><div class="line">  <span class="keyword">switch</span> (responseCode) &#123;</div><div class="line">   <span class="comment">// HTTP Status-Code 407: Proxy Authentication Required.</span></div><div class="line">   <span class="comment">// 需要代理，则调用创建okhttp对象的时候设置的代理对象</span></div><div class="line">    <span class="keyword">case</span> HTTP_PROXY_AUTH:</div><div class="line">      Proxy selectedProxy = route != <span class="keyword">null</span></div><div class="line">          ? route.proxy()</div><div class="line">          : client.proxy();</div><div class="line">      <span class="keyword">if</span> (selectedProxy.type() != Proxy.Type.HTTP) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Received HTTP_PROXY_AUTH (407) code while not using proxy"</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> client.proxyAuthenticator().authenticate(route, userResponse);</div><div class="line">    <span class="comment">//  HTTP Status-Code 401: Unauthorized.</span></div><div class="line">    <span class="comment">// 需要身份验证，则调用创建okhttp对象的时候设置的验证对象，加入对应的信息</span></div><div class="line">    <span class="keyword">case</span> HTTP_UNAUTHORIZED:</div><div class="line">      <span class="keyword">return</span> client.authenticator().authenticate(route, userResponse);</div><div class="line"></div><div class="line">    <span class="keyword">case</span> HTTP_PERM_REDIRECT:</div><div class="line">    <span class="keyword">case</span> HTTP_TEMP_REDIRECT:</div><div class="line">      <span class="comment">// "If the 307 or 308 status code is received in response to a request other than GET</span></div><div class="line">      <span class="comment">// or HEAD, the user agent MUST NOT automatically redirect the request"</span></div><div class="line">      <span class="keyword">if</span> (!method.equals(<span class="string">"GET"</span>) &amp;&amp; !method.equals(<span class="string">"HEAD"</span>)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// fall-through</span></div><div class="line">    <span class="keyword">case</span> HTTP_MULT_CHOICE:</div><div class="line">    <span class="keyword">case</span> HTTP_MOVED_PERM:</div><div class="line">    <span class="keyword">case</span> HTTP_MOVED_TEMP:</div><div class="line">    <span class="keyword">case</span> HTTP_SEE_OTHER:</div><div class="line">      <span class="comment">// Does the client allow redirects?</span></div><div class="line">      <span class="keyword">if</span> (!client.followRedirects()) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">      <span class="comment">// Header 头中读取Location字段</span></div><div class="line">      String location = userResponse.header(<span class="string">"Location"</span>);</div><div class="line">      <span class="keyword">if</span> (location == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">      <span class="comment">// 通过Location字段的值构造新的请求的url</span></div><div class="line">      HttpUrl url = userResponse.request().url().resolve(location);</div><div class="line"></div><div class="line">      <span class="comment">// Don't follow redirects to unsupported protocols.</span></div><div class="line">      <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">      <span class="comment">// If configured, don't follow redirects between SSL and non-SSL.</span></div><div class="line">      <span class="keyword">boolean</span> sameScheme = url.scheme().equals(userResponse.request().url().scheme());</div><div class="line">      <span class="keyword">if</span> (!sameScheme &amp;&amp; !client.followSslRedirects()) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">      <span class="comment">// Most redirects don't include a request body.</span></div><div class="line">      Request.Builder requestBuilder = userResponse.request().newBuilder();</div><div class="line">      <span class="keyword">if</span> (HttpMethod.permitsRequestBody(method)) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> maintainBody = HttpMethod.redirectsWithBody(method);</div><div class="line">        <span class="comment">// 除了PROPFIND(WebDAV用的)请求，其他请求都要转为GET请求</span></div><div class="line">        <span class="keyword">if</span> (HttpMethod.redirectsToGet(method)) &#123;</div><div class="line">          requestBuilder.method(<span class="string">"GET"</span>, <span class="keyword">null</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          RequestBody requestBody = maintainBody ? userResponse.request().body() : <span class="keyword">null</span>;</div><div class="line">          requestBuilder.method(method, requestBody);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!maintainBody) &#123;</div><div class="line">          requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</div><div class="line">          requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</div><div class="line">          requestBuilder.removeHeader(<span class="string">"Content-Type"</span>);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// When redirecting across hosts, drop all authentication headers. This</span></div><div class="line">      <span class="comment">// is potentially annoying to the application layer since they have no</span></div><div class="line">      <span class="comment">// way to retain them.</span></div><div class="line">      <span class="keyword">if</span> (!sameConnection(userResponse, url)) &#123;</div><div class="line">        requestBuilder.removeHeader(<span class="string">"Authorization"</span>);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">return</span> requestBuilder.url(url).build();</div><div class="line"></div><div class="line">    <span class="keyword">case</span> HTTP_CLIENT_TIMEOUT:</div><div class="line">      <span class="comment">// 408's are rare in practice, but some servers like HAProxy use this response code. The</span></div><div class="line">      <span class="comment">// spec says that we may repeat the request without modifications. Modern browsers also</span></div><div class="line">      <span class="comment">// repeat the request (even non-idempotent ones.)</span></div><div class="line">      <span class="keyword">if</span> (userResponse.request().body() <span class="keyword">instanceof</span> UnrepeatableRequestBody) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 超时返回原始的请求，就代表重新请求</span></div><div class="line">      <span class="keyword">return</span> userResponse.request();</div><div class="line"></div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要的解析都在代码中以注释的形式出现了。<br>到这里，这个Interceptor就解析完毕了，我们来看看文章最开头链上下一个Interceptor:</p>
<h3 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h3><p>作为框架，不可能要求所有使用者都对HTTP协议理解的很深刻。所以，框架需要将HTTP协议中约定的信息加入其中，要让使用者尽可能少的处理HTTP协议的细节，这就是这个Interceptor的任务。</p>
<h4 id="interceptor-1"><a href="#interceptor-1" class="headerlink" title="interceptor()"></a>interceptor()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  Request userRequest = chain.request();</div><div class="line">  Request.Builder requestBuilder = userRequest.newBuilder();</div><div class="line"></div><div class="line">  RequestBody body = userRequest.body();</div><div class="line">  <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</div><div class="line">    MediaType contentType = body.contentType();</div><div class="line">    <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</div><div class="line">      requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString());</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// 从这里可以看出，HTTP请求头的Content-Length和Transfer-Encoding是互斥的</span></div><div class="line">    <span class="keyword">long</span> contentLength = body.contentLength();</div><div class="line">    <span class="keyword">if</span> (contentLength != -<span class="number">1</span>) &#123;</div><div class="line">      requestBuilder.header(<span class="string">"Content-Length"</span>, Long.toString(contentLength));</div><div class="line">      requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      requestBuilder.header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>);</div><div class="line">      requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (userRequest.header(<span class="string">"Host"</span>) == <span class="keyword">null</span>) &#123;</div><div class="line">    requestBuilder.header(<span class="string">"Host"</span>, hostHeader(userRequest.url(), <span class="keyword">false</span>));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (userRequest.header(<span class="string">"Connection"</span>) == <span class="keyword">null</span>) &#123;</div><div class="line">    requestBuilder.header(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing</span></div><div class="line">  <span class="comment">// the transfer stream.</span></div><div class="line">  <span class="keyword">boolean</span> transparentGzip = <span class="keyword">false</span>;</div><div class="line">  <span class="comment">// 不指定Accept-Encoding请求头，默认使用gzip，压缩数据</span></div><div class="line">  <span class="keyword">if</span> (userRequest.header(<span class="string">"Accept-Encoding"</span>) == <span class="keyword">null</span>) &#123;</div><div class="line">    transparentGzip = <span class="keyword">true</span>;</div><div class="line">    requestBuilder.header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</div><div class="line">  <span class="keyword">if</span> (!cookies.isEmpty()) &#123;</div><div class="line">    requestBuilder.header(<span class="string">"Cookie"</span>, cookieHeader(cookies));</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 用户设置了UA,这里就不能覆盖了，否则使用当前okhttp版本作为UA</span></div><div class="line">  <span class="keyword">if</span> (userRequest.header(<span class="string">"User-Agent"</span>) == <span class="keyword">null</span>) &#123;</div><div class="line">    requestBuilder.header(<span class="string">"User-Agent"</span>, Version.userAgent());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Response networkResponse = chain.proceed(requestBuilder.build());</div><div class="line"></div><div class="line">  HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</div><div class="line"></div><div class="line">  Response.Builder responseBuilder = networkResponse.newBuilder()</div><div class="line">      .request(userRequest);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (transparentGzip</div><div class="line">      &amp;&amp; <span class="string">"gzip"</span>.equalsIgnoreCase(networkResponse.header(<span class="string">"Content-Encoding"</span>))</div><div class="line">      &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</div><div class="line">      <span class="comment">// 因为响应式gzip编码，所以需要先解压</span></div><div class="line">    GzipSource responseBody = <span class="keyword">new</span> GzipSource(networkResponse.body().source());</div><div class="line">    Headers strippedHeaders = networkResponse.headers().newBuilder()</div><div class="line">        .removeAll(<span class="string">"Content-Encoding"</span>)</div><div class="line">        .removeAll(<span class="string">"Content-Length"</span>)</div><div class="line">        .build();</div><div class="line">    responseBuilder.headers(strippedHeaders);</div><div class="line">    responseBuilder.body(<span class="keyword">new</span> RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> responseBuilder.build();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里理解起来很容易，看代码中的注释即可，接下来看下一个Interceptor:</p>
<h3 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h3><p>网络请求毕竟是一个缓慢的操作，所以，可以通过缓存来加速，但是，不能所有都缓存，也不能什么情况下都从缓存中拿数据，这里就是处理这个逻辑的地方。</p>
<h4 id="intercept"><a href="#intercept" class="headerlink" title="intercept()"></a>intercept()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  Response cacheCandidate = cache != <span class="keyword">null</span></div><div class="line">      ? cache.get(chain.request())</div><div class="line">      : <span class="keyword">null</span>;</div><div class="line"></div><div class="line">  <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line">  <span class="comment">// 根据HTTP的Date|Expires|Last-Modified|ETag|Age头来确定对应的策略</span></div><div class="line">  CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</div><div class="line">  Request networkRequest = strategy.networkRequest;</div><div class="line">  Response cacheResponse = strategy.cacheResponse;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</div><div class="line">    cache.trackResponse(strategy);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (cacheCandidate != <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</div><div class="line">    closeQuietly(cacheCandidate.body()); <span class="comment">// The cache candidate wasn't applicable. Close it.</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// If we're forbidden from using the network and the cache is insufficient, fail.</span></div><div class="line">  <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</div><div class="line">        .request(chain.request())</div><div class="line">        .protocol(Protocol.HTTP_1_1)</div><div class="line">        .code(<span class="number">504</span>)</div><div class="line">        .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</div><div class="line">        .body(Util.EMPTY_RESPONSE)</div><div class="line">        .sentRequestAtMillis(-<span class="number">1L</span>)</div><div class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</div><div class="line">        .build();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// If we don't need the network, we're done.</span></div><div class="line">  <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> cacheResponse.newBuilder()</div><div class="line">        .cacheResponse(stripBody(cacheResponse))</div><div class="line">        .build();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Response networkResponse = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    networkResponse = chain.proceed(networkRequest);</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="comment">// If we're crashing on I/O or otherwise, don't leak the cache body.</span></div><div class="line">    <span class="keyword">if</span> (networkResponse == <span class="keyword">null</span> &amp;&amp; cacheCandidate != <span class="keyword">null</span>) &#123;</div><div class="line">      closeQuietly(cacheCandidate.body());</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// If we have a cache response too, then we're doing a conditional get.</span></div><div class="line">  <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">// HTTP Status-Code 304: Not Modified. </span></div><div class="line">    <span class="comment">// 存在缓存，服务端还返回这个HTTP状态码</span></div><div class="line">    <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</div><div class="line">      Response response = cacheResponse.newBuilder()</div><div class="line">          .headers(combine(cacheResponse.headers(), networkResponse.headers()))</div><div class="line">          .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</div><div class="line">          .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</div><div class="line">          .cacheResponse(stripBody(cacheResponse))</div><div class="line">          .networkResponse(stripBody(networkResponse))</div><div class="line">          .build();</div><div class="line">      networkResponse.body().close();</div><div class="line"></div><div class="line">      <span class="comment">// Update the cache after combining headers but before stripping the</span></div><div class="line">      <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></div><div class="line">      cache.trackConditionalCacheHit();</div><div class="line">      cache.update(cacheResponse, response);</div><div class="line">      <span class="keyword">return</span> response;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      closeQuietly(cacheResponse.body());</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Response response = networkResponse.newBuilder()</div><div class="line">      .cacheResponse(stripBody(cacheResponse))</div><div class="line">      .networkResponse(stripBody(networkResponse))</div><div class="line">      .build();</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (HttpHeaders.hasBody(response)) &#123;</div><div class="line">    CacheRequest cacheRequest = maybeCache(response, networkResponse.request(), cache);</div><div class="line">    response = cacheWritingResponse(cacheRequest, response);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> response;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里主要通过<code>CacheStrategy</code>类来管理Cache的储存策略，比如要不要保存Cache，保存Cache的超时时间等等，详细内容看这个类即可。<br>如果没网，不存在Cache就返回504状态码的响应，否则返回cache响应。<br>通过网络请求获取响应。响应的状态码304的情况下，还存在缓存，则更新缓存，返回对应的响应。<br>最后，不存在缓存的情况下去除cacheResponse和networkResponse的body，返回通过请求获取的响应。</p>
<p>接着看下一个Interceptor:</p>
<h3 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h3><p>这个Interceptor的作用就是建立与服务端的连接，为什么将连接服务器和服务器之间的交互分开呢？我觉得因为提供的networkInterceptors对象，这个对象给了框架使用者这样一种能力，在连接到服务器的时候做一些需要的操作（我暂时没遇到这样的需求，所以对这里理解不深，大家有想法的可以在评论里告诉我）</p>
<h4 id="intercept-1"><a href="#intercept-1" class="headerlink" title="intercept()"></a>intercept()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  RealInterceptorChain realChain = (RealInterceptorChain) chain;</div><div class="line">  Request request = realChain.request();</div><div class="line">  StreamAllocation streamAllocation = realChain.streamAllocation();</div><div class="line"></div><div class="line">  <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></div><div class="line">  <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">"GET"</span>);</div><div class="line">  HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);</div><div class="line">  RealConnection connection = streamAllocation.connection();</div><div class="line"></div><div class="line">  <span class="keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还记得分析<code>RetryAndFollowUpInterceptor</code>过程中出现的<code>StreamAllocation</code>对象吗？这里又出现，根据前面说的，HttpCodec就是一个Stream，RealConnection就是Connection。那也就意味着，逻辑的HTTP请求响应是HttpCodec负责处理的。</p>
<p>这里就简单分析一下<code>HttpCodec</code>,对它有个具体的认识，到分析下一个Interceptor的时候，才不会那么头疼。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Encodes HTTP requests and decodes HTTP responses. */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpCodec</span> </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * The timeout to use while discarding a stream of input data. Since this is used for connection</div><div class="line">   * reuse, this timeout should be significantly less than the time it takes to establish a new</div><div class="line">   * connection.</div><div class="line">   */</div><div class="line">  <span class="keyword">int</span> DISCARD_STREAM_TIMEOUT_MILLIS = <span class="number">100</span>;</div><div class="line"></div><div class="line">  <span class="comment">/** Returns an output stream where the request body can be streamed. */</span></div><div class="line">  <span class="function">Sink <span class="title">createRequestBody</span><span class="params">(Request request, <span class="keyword">long</span> contentLength)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/** This should update the HTTP engine's sentRequestMillis field. */</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">writeRequestHeaders</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"></div><div class="line">  <span class="comment">/** Flush the request to the underlying socket. */</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">finishRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"></div><div class="line">  <span class="comment">/** Read and return response headers. */</span></div><div class="line">  Response.<span class="function">Builder <span class="title">readResponseHeaders</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"></div><div class="line">  <span class="comment">/** Returns a stream that reads the response body. */</span></div><div class="line">  <span class="function">ResponseBody <span class="title">openResponseBody</span><span class="params">(Response response)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Cancel this stream. Resources held by this stream will be cleaned up, though not synchronously.</div><div class="line">   * That may happen later by the connection pool thread.</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到<code>HttpCodec</code>是一个接口，为什么是一个接口呢？因为HTTP协议的兼容性问题，HTTP现在已经存在两种实现了，分为HTTP1和HTTP2，HTTP协议的不同，当然，进行这些操作的实现方式也不一样，所以，通过接口隔离具体协议实现方式的不同。当然，具体的实现在<code>streamAllocation.newStream()</code>这里，通过连接到服务器，服务器会返回接受的协议，发现服务端接受”h2”，则使用<code>Http2Codec</code>，否则使用<code>Http1Codec</code></p>
<p>好了，终于到了最后一个Interceptor:</p>
<h3 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h3><p>前面的Interceptor做了这么多铺垫，就等着最后一个Interceptor完成最后一步，向服务端发送请求，从服务端获取请求。</p>
<h4 id="intercept-2"><a href="#intercept-2" class="headerlink" title="intercept()"></a>intercept()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  HttpCodec httpCodec = ((RealInterceptorChain) chain).httpStream();</div><div class="line">  StreamAllocation streamAllocation = ((RealInterceptorChain) chain).streamAllocation();</div><div class="line">  Request request = chain.request();</div><div class="line"></div><div class="line">  <span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</div><div class="line">  <span class="comment">// 发送request header</span></div><div class="line">  httpCodec.writeRequestHeaders(request);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</div><div class="line">  <span class="comment">// 发送request body</span></div><div class="line">    Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());</div><div class="line">    BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</div><div class="line">    request.body().writeTo(bufferedRequestBody);</div><div class="line">    bufferedRequestBody.close();</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 完成request</span></div><div class="line">  httpCodec.finishRequest();</div><div class="line">  <span class="comment">// 读取response header</span></div><div class="line">  Response response = httpCodec.readResponseHeaders()</div><div class="line">      .request(request)</div><div class="line">      .handshake(streamAllocation.connection().handshake())</div><div class="line">      .sentRequestAtMillis(sentRequestMillis)</div><div class="line">      .receivedResponseAtMillis(System.currentTimeMillis())</div><div class="line">      .build();</div><div class="line"></div><div class="line">  <span class="keyword">int</span> code = response.code();</div><div class="line">  <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</div><div class="line">    <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></div><div class="line">    response = response.newBuilder()</div><div class="line">        .body(Util.EMPTY_RESPONSE)</div><div class="line">        .build();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    response = response.newBuilder()</div><div class="line">        .body(httpCodec.openResponseBody(response))</div><div class="line">        .build();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">if</span> (<span class="string">"close"</span>.equalsIgnoreCase(response.request().header(<span class="string">"Connection"</span>))</div><div class="line">      || <span class="string">"close"</span>.equalsIgnoreCase(response.header(<span class="string">"Connection"</span>))) &#123;</div><div class="line">    streamAllocation.noNewStreams();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(</div><div class="line">        <span class="string">"HTTP "</span> + code + <span class="string">" had non-zero Content-Length: "</span> + response.body().contentLength());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> response;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要流程是:</p>
<ol>
<li>发送request header</li>
<li>存在request body,发送给服务端</li>
<li>完成request</li>
<li>读取服务端response header，生成Response对象</li>
<li>存在response body,则将body添加到上一步生成的Response对象里</li>
</ol>
<p>好了，到这里我们就把Interceptor链给分析完毕了。然后Response对象就一层层的返回到之前的Interceptors里了。如果前面的Interceptor关心Response，就重新进行这样的链式处理，否则就返回给我们调用网络请求的地方，这样我们就拿到了需要的Response对象。</p>
<p>通过我们的分析，可以看出，这个责任链把功能分层分的淋漓尽致，需要什么功能，加一个专门的Interceptor即可，了解到了这样一种简洁干净的设计，以后写代码的时候就可以借鉴一下。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://air.com/2016/12/03/OkHttp源码解析-(上)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Air">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Air Little Place">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/03/OkHttp源码解析-(上)/" itemprop="url">OkHttp源码解析-(上)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-03T00:00:00+08:00">
                2016-12-03
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/03/OkHttp源码解析-(上)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2016/12/03/OkHttp源码解析-(上)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一直都知道Retrofit-OkHttp-Okio是Square公司封装的用于网络请求的大杀器，项目中也往往都在用Retrofit，看过我之前的文章的朋友应该看到过我的Retrofit源码解析系列， 但是一直没空往下继续深入，去解析OkHttp和Okio，毕竟Retrofit2.0本身就是搭建于OkHttp之上的。</p>
<p>老规矩，先讲一下这个库如何用，最后渐渐的一步步走到这个库的处理过程。</p>
<h3 id="如何使用OkHttp"><a href="#如何使用OkHttp" class="headerlink" title="如何使用OkHttp"></a>如何使用OkHttp</h3><p>官方文档很详细的解释了如何使用OkHttp，我们只要一步步跟着就可以了。至于OkHttp优点，或者说为什么使用OkHttp我在这里就略过不提，相信你在看源码的过程中会有自己的理解。</p>
<p>大家在平常的http请求中，最常见的就是使用GET和POST请求，所以，官方Demo也就主要描述了如何处理这两种请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</div><div class="line"></div><div class="line"><span class="function">String <span class="title">get</span><span class="params">(String url)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  Request request = <span class="keyword">new</span> Request.Builder()</div><div class="line">      .url(url)</div><div class="line">      .build();</div><div class="line"></div><div class="line">  Response response = client.newCall(request).execute();</div><div class="line">  <span class="keyword">return</span> response.body().string();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType JSON</div><div class="line">    = MediaType.parse(<span class="string">"application/json; charset=utf-8"</span>);</div><div class="line">    </div><div class="line"><span class="function">String <span class="title">post</span><span class="params">(String url, String json)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  RequestBody body = RequestBody.create(JSON, json);</div><div class="line">  Request request = <span class="keyword">new</span> Request.Builder()</div><div class="line">      .url(url)</div><div class="line">      .post(body)</div><div class="line">      .build();</div><div class="line">  Response response = client.newCall(request).execute();</div><div class="line">  <span class="keyword">return</span> response.body().string();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里可以看出，想要完成一次请求需要以下几个过程：</p>
<ol>
<li>构造<code>OkHttpClient</code>对象</li>
<li>创建Request</li>
<li>调用<code>OkHttpClient</code>对象的<code>newCall()</code>方法构造<code>Call</code>对象</li>
<li>调用<code>Call</code>对象的<code>execute()</code>方法获取<code>Response</code></li>
</ol>
<h3 id="OkHttp-整体调用流程"><a href="#OkHttp-整体调用流程" class="headerlink" title="OkHttp 整体调用流程"></a>OkHttp 整体调用流程</h3><p><img src="/img/okhttp/OkHttp3.4.1.jpg" alt=""></p>
<p>这次先看图，有了图，跟代码的时候才不会在代码中迷失。</p>
<h3 id="OkHttp源码解读"><a href="#OkHttp源码解读" class="headerlink" title="OkHttp源码解读"></a>OkHttp源码解读</h3><h4 id="OkHttpClient对象"><a href="#OkHttpClient对象" class="headerlink" title="OkHttpClient对象"></a><code>OkHttpClient</code>对象</h4><p>参考流程图，我们先需要一个<code>OkHttpClient</code>对象，这个对象需要许多参数，所以用建造者模式构建，当然，每个参数都提供了默认值，也可以直接用<code>OkHttpClient</code>的构造函数来使用默认的实现。</p>
<p>这是各个参数的默认值，需要修改的通过Builder直接修改即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</div><div class="line">  dispatcher = <span class="keyword">new</span> Dispatcher();</div><div class="line">  protocols = DEFAULT_PROTOCOLS;</div><div class="line">  connectionSpecs = DEFAULT_CONNECTION_SPECS;</div><div class="line">  proxySelector = ProxySelector.getDefault();</div><div class="line">  cookieJar = CookieJar.NO_COOKIES;</div><div class="line">  socketFactory = SocketFactory.getDefault();</div><div class="line">  hostnameVerifier = OkHostnameVerifier.INSTANCE;</div><div class="line">  certificatePinner = CertificatePinner.DEFAULT;</div><div class="line">  proxyAuthenticator = Authenticator.NONE;</div><div class="line">  authenticator = Authenticator.NONE;</div><div class="line">  connectionPool = <span class="keyword">new</span> ConnectionPool();</div><div class="line">  dns = Dns.SYSTEM;</div><div class="line">  followSslRedirects = <span class="keyword">true</span>;</div><div class="line">  followRedirects = <span class="keyword">true</span>;</div><div class="line">  retryOnConnectionFailure = <span class="keyword">true</span>;</div><div class="line">  connectTimeout = <span class="number">10_000</span>;</div><div class="line">  readTimeout = <span class="number">10_000</span>;</div><div class="line">  writeTimeout = <span class="number">10_000</span>;</div><div class="line">  pingInterval = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Call对象"><a href="#Call对象" class="headerlink" title="Call对象"></a><code>Call</code>对象</h4><p>接下来就需要发请求了，发请求需要一个<code>Call</code>对象, 我们通过<code>newCall()</code>方法获取这个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，真正调用的<code>Call</code>实现类是<code>RealCall</code>这个类,默认情况下，这个<code>RealCall</code>对象的<code>forWebSocket</code>属性为false。</p>
<h4 id="执行请求"><a href="#执行请求" class="headerlink" title="执行请求"></a>执行请求</h4><p>构造完<code>Call</code>对象，通过<code>Call</code>对象的<code>execute()</code>方法同步的执行请求或者<code>enqueue()</code>方法异步的执行请求。</p>
<p>这里看一下图，会感觉图中的线在这里很密集，而且<code>Dispatcher</code>对象的线会指给这么多的方法，等我们进入源码中，就可以仔细了解了。</p>
<h5 id="RealCall-execute"><a href="#RealCall-execute" class="headerlink" title="RealCall execute()"></a>RealCall execute()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</div><div class="line">    executed = <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  captureCallStackTrace();</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    client.dispatcher().executed(<span class="keyword">this</span>);</div><div class="line">    Response result = getResponseWithInterceptorChain();</div><div class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    client.dispatcher().finished(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="RealCall-enqueue"><a href="#RealCall-enqueue" class="headerlink" title="RealCall enqueue()"></a>RealCall enqueue()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</div><div class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</div><div class="line">    executed = <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  captureCallStackTrace();</div><div class="line">  client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，这里面的方法都会调用<code>Dispatcher</code>对象的方法，所以，图中从<code>Dispatcher</code>对象中发出3条线，代表对应方法执行过程中调用<code>Dispatcher</code>对象的方法。</p>
<p>虽然<code>Dispatcher</code>对象在同步和异步的请求中都有它身影的出现，<br>但是，它主要作用是在异步请求中，开线程池执行异步请求，并用队列保持准备执行的请求。</p>
<h5 id="Dispatcher-enqueue"><a href="#Dispatcher-enqueue" class="headerlink" title="Dispatcher enqueue()"></a>Dispatcher enqueue()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</div><div class="line">    runningAsyncCalls.add(call);  <span class="comment">// runningAsyncCalls是一个队列</span></div><div class="line">    executorService().execute(call); <span class="comment">// executorService是一个线程池</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    readyAsyncCalls.add(call); <span class="comment">// readyAsyncCalls是一个队列</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在同步请求中，它的作用是保存当前正在执行的请求，那么为什么要进行这样一个操作呢？</p>
<h5 id="Dispatcher-executed"><a href="#Dispatcher-executed" class="headerlink" title="Dispatcher executed()"></a>Dispatcher executed()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">executed</span><span class="params">(RealCall call)</span> </span>&#123;</div><div class="line">  runningSyncCalls.add(call); <span class="comment">// runningSyncCalls是一个队列</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查看<code>Dispatcher</code>对象的方法，发现有个<code>cancelAll()</code>方法，原来给用户提供了取消所有请求的操作，那么当前执行的同步请求依旧是要被cancel的，所以，自然要把当前正在执行的同步请求加入其中了。</p>
<h5 id="Dispatcher-cancelAll"><a href="#Dispatcher-cancelAll" class="headerlink" title="Dispatcher cancelAll()"></a>Dispatcher cancelAll()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">cancelAll</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (AsyncCall call : readyAsyncCalls) &#123;</div><div class="line">    call.get().cancel();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (AsyncCall call : runningAsyncCalls) &#123;</div><div class="line">    call.get().cancel();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (RealCall call : runningSyncCalls) &#123;</div><div class="line">    call.cancel();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后获取到<code>Response</code>对象的时候，通知<code>Dispatcher</code>请求结束了，<code>Dispatcher</code>就会在队列里移除相应的请求，所以图中<code>Dispatcher</code>对象还有一条线指向<code>Response</code>对象。</p>
<p>重新回到<code>RealCall</code>对象，发现无论同步还是异步请求，获取<code>Response</code>的方式都是通过</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Response response = getResponseWithInterceptorChain();</div></pre></td></tr></table></figure>
<p>这样获取的。</p>
<p>我们通过这个方法就获取了<code>Response</code>对象，说明这个方法为我们做了真正发请求的工作，那么我们先看一张图，看这么复杂的工作，这个方法是如何实现的。</p>
<p><img src="/img/okhttp/OkHttp3.4.1-interceptors.jpg" alt=""></p>
<p>从图中可以看到，这个执行过程像链条一样一环套一环，如果熟悉设计模式，这不就是很好的责任链模式嘛。好了，我们看一下它这里具体做了什么。</p>
<h5 id="RealCall-getResponseWithInterceptorChain"><a href="#RealCall-getResponseWithInterceptorChain" class="headerlink" title="RealCall getResponseWithInterceptorChain()"></a>RealCall getResponseWithInterceptorChain()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  <span class="comment">// Build a full stack of interceptors.</span></div><div class="line">  List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  interceptors.addAll(client.interceptors());</div><div class="line">  interceptors.add(retryAndFollowUpInterceptor);</div><div class="line">  interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</div><div class="line">  interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</div><div class="line">  interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</div><div class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</div><div class="line">    interceptors.addAll(client.networkInterceptors());</div><div class="line">  &#125;</div><div class="line">  interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</div><div class="line"></div><div class="line">  Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(</div><div class="line">      interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, originalRequest);</div><div class="line">  <span class="keyword">return</span> chain.proceed(originalRequest);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，这其中有下面几种拦截器进行操作。</p>
<ol>
<li>在配置 OkHttpClient 时设置的 interceptors；</li>
<li>负责失败重试以及重定向的 RetryAndFollowUpInterceptor；</li>
<li>负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应的 BridgeInterceptor；<br>4.负责读取缓存直接返回、更新缓存的 CacheInterceptor；</li>
<li>负责和服务器建立连接的 ConnectInterceptor；</li>
<li>配置 OkHttpClient 时设置的 networkInterceptors；</li>
<li>负责向服务器发送请求数据、从服务器读取响应数据的 CallServerInterceptor。</li>
</ol>
<p>可以看到，这个方法最终执行的是<code>RealInterceptorChain</code>对象的<code>process()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span></div><div class="line">    Connection connection) <span class="keyword">throws</span> IOException &#123;</div><div class="line">  <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</div><div class="line"></div><div class="line">  calls++;</div><div class="line">  </div><div class="line">  <span class="comment">// If we already have a stream, confirm that the incoming request will use it.</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; !sameConnection(request.url())) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</div><div class="line">        + <span class="string">" must retain the same host and port"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// If we already have a stream, confirm that this is the only call to chain.proceed().</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; calls &gt; <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</div><div class="line">        + <span class="string">" must call proceed() exactly once"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Call the next interceptor in the chain.</span></div><div class="line">  RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(</div><div class="line">      interceptors, streamAllocation, httpCodec, connection, index + <span class="number">1</span>, request);</div><div class="line">  Interceptor interceptor = interceptors.get(index);</div><div class="line">  Response response = interceptor.intercept(next);</div><div class="line"></div><div class="line">  <span class="comment">// Confirm that the next interceptor made its required call to chain.proceed().</span></div><div class="line">  <span class="keyword">if</span> (httpCodec != <span class="keyword">null</span> &amp;&amp; index + <span class="number">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptor</div><div class="line">        + <span class="string">" must call proceed() exactly once"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Confirm that the intercepted response isn't null.</span></div><div class="line">  <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"interceptor "</span> + interceptor + <span class="string">" returned null"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> response;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果不关心异常状况，核心代码就是如下几行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// Call the next interceptor in the chain.</span></div><div class="line">RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(</div><div class="line">    interceptors, streamAllocation, httpCodec, connection, index + <span class="number">1</span>, request);</div><div class="line">Interceptor interceptor = interceptors.get(index);</div><div class="line">Response response = interceptor.intercept(next);</div></pre></td></tr></table></figure>
<p>在<code>process()</code>的过程中，做了如下几个操作：</p>
<ol>
<li>生成新的<code>RealInterceptorChain</code>对象</li>
<li>按<code>index</code>获取当前interceptors列表中<code>Interceptor</code>对象</li>
<li>调用<code>Interceptor</code>对象的<code>intercept()</code>方法，并将新的<code>RealInterceptorChain</code>传给<code>Interceptor</code>对象。</li>
</ol>
<p>这样，只要<code>Interceptor</code>对象在<code>intercept()</code>方法执行过程中调用<code>Chain</code>对象的<code>proceed()</code>方法，就会调用传给<code>Interceptor</code>对象的下一个<code>RealInterceptorChain</code>对象的<code>proceed()</code>方法。这样，就像上面说的，一条链一样的不停调用。</p>
<p>好了，上半部分的分析暂时就到这里了，下半部分对各个<code>Interceptor</code>进行分析。</p>
<p>参考: <a href="http://blog.piasy.com/2016/07/11/Understand-OkHttp/" target="_blank" rel="external">拆轮子系列：拆 OkHttp</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://air.com/2016/10/11/Jenkins使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Air">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Air Little Place">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/11/Jenkins使用/" itemprop="url">Jenkins的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-11T00:00:00+08:00">
                2016-10-11
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/10/11/Jenkins使用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2016/10/11/Jenkins使用/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>前提: 使用Git作为公司的版本控制工具，使用GitLab作为对应的服务器</strong></p>
<p>首先安装Jenkins plugins, 下面列出两个关键的Plugins</p>
<p><a href="https://wiki.jenkins-ci.org/display/JENKINS/GitLab+Plugin" target="_blank" rel="external">GitLab Plugin</a></p>
<p><a href="https://wiki.jenkins-ci.org/display/JENKINS/Git+Plugin" target="_blank" rel="external">Git plugin</a></p>
<h3 id="打包APK"><a href="#打包APK" class="headerlink" title="打包APK"></a>打包APK</h3><p>对于APK的打包，相信大家公司内部都有不同的测试环境，不同的功能需要在不同的测试环境上测试，不同的功能又对应不同的分支，如果开发人员负责根据测试人员的需求打包的话，测试人员麻烦，开发人员也麻烦。程序员一个极好的特质就是懒，那么，这时候，Jenkins提供的<code>This build is parameterized</code>功能就派上了用处。</p>
<p><img src="/img/jenkins/build_params.png" alt=""></p>
<p>勾选了这个选项之后，就可以添加自己需要的参数了，比如:</p>
<p><img src="/img/jenkins/url.png" alt="测试环境地址 "><br><img src="/img/jenkins/git_branch.png" alt="git的分支名称"></p>
<p>记住这个地方填写的<code>name</code>， 这里的名称将会是shell里的变量，使用$来引用对应具体的变量，下面将会看到这些变量的使用。</p>
<p>既然环境和分支都已经可选，第二步是配置Jenkins去哪个地址拉源代码，即SCM配置，如下图:<br><img src="/img/jenkins/scm_git.png" alt=""></p>
<p>可以看到，在<code>Branches to build</code>的地方，我填的内容是<code>*/$git_branch</code>，这个参数就是从前面<code>This build is parameterized</code>位置添加的参数，所以用户填了哪个分支，这里就能拿到用户填写的分支，在Build的时候也就会拉对应分支的代码。</p>
<p>按照我们的意向拉了对应分支的代码，开头所说的另外一个问题，更改对应的环境，当然，可以使用<code>ProductFlavor</code>来解决这个问题，再最后打包的情况下选择对应的<code>ProductFlavor</code>，数量少了还好说，数量多了，就会变得很麻烦。因此，这里在<code>Build Environment</code>的地方，打勾<br><code>Executor shell script on remote host using ssh</code>，如下图<br><img src="/img/jenkins/change_env.png" alt=""></p>
<p>这里需要插件<a href="https://wiki.jenkins.io/display/JENKINS/SSH+plugin?focusedCommentId=43713480" target="_blank" rel="external">SSH Plugin</a>的支持</p>
<p>在<code>Pre build script</code>的地方，修改你工程中决定使用哪个环境的文件，这里就可以使用最开头的<code>$url_host</code>那个设定的参数。</p>
<p>当然还有<code>Post build script</code>，需要的话就同样写一段shell来达到你的目的。</p>
<p>有些情况下，你需要获取这次打包对应的git信息，可以看到，每个打包都有一个Git Build Data，这里面有对应的git信息，所以，勾选<code>inject environment variables to the build process</code>即可将对应的信息添加到这次打包的环境变量中。<br>这个需要<a href="https://wiki.jenkins-ci.org/display/JENKINS/EnvInject+Plugin" target="_blank" rel="external">Environment Injector Plugin</a>插件的支持。<br>这里有个问题，就是<code>Evaluated  Groovy Script</code>脚本的执行过程中，使用正常方式无法获取所有的Jenkins环境变量，那么需要使用<code>currentBuild.getEnvironment(currentListener).get(&#39;var&#39;)</code>来获取var的环境变量。currentBuild和currentListener在Evaluated  Groovy Script右边的<code>?</code>说明里</p>
<p><img src="/img/jenkins/build_env_inject.png" alt=""></p>
<p>最后，测试人员肯定希望能下载打包完成的APK，那么在最后的<code>Post-build Actions</code>即可实现该需求。</p>
<p><img src="/img/jenkins/post_build_action.png" alt=""></p>
<p>在<code>Archive the artifacts</code>里面填入打包完成的apk的路径，则Jenkins会以可以下载的形式输出该Apk的链接在对应的打包完成页面。</p>
<h3 id="打包AAR"><a href="#打包AAR" class="headerlink" title="打包AAR"></a>打包AAR</h3><p>打包AAR和打包APK的需求是不同的，对于AAR的输出，一定希望对开发透明，不需要任何人去点一下build，才去打包AAR，这个时候，我们前面安装的GitLab Plugin就十分有用。有了它，我们可以设定触发打包任务的条件:</p>
<p><img src="/img/jenkins/build_trigger.png" alt=""></p>
<p>画红线的URL代表  GitLab WebHook需要回调的URL，即GitLab收到某些事件(push, merge request ..etc)，将会调用该URL，此时将会触发打包。在最下面还有个红线，就是指定相应的分支，在这些分支另在GitLab WebHook回调的时候才进行打包，公司的特殊需求即可在这里定制。</p>
<p>有可能你想流式的打包，也可能你的aar有优先级，换句话说，A aar可能依赖B aar，那么一定要B aar打包完毕后，才能打包A aar，那样的话你就需要下面这个插件<br><a href="https://wiki.jenkins-ci.org/display/JENKINS/Parameterized+Trigger+Plugin" target="_blank" rel="external">Jenkins Parameterized Trigger plugin</a><br>这个插件将前一个打包aar的Build Env传给后一个打包aar的过程中，那样，就拥有一致的Build Env了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://air.com/2016/05/22/retrofit2.0源码解析(下)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Air">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Air Little Place">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/22/retrofit2.0源码解析(下)/" itemprop="url">Retrofit2源码分析-(下)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-22T00:00:00+08:00">
                2016-05-22
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/05/22/retrofit2.0源码解析(下)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2016/05/22/retrofit2.0源码解析(下)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>  上篇我们主要看了一下Retrofit的设计者对Retrofit1.+版本设计的评价（好的方面和坏的方面），同时也讲了Retrofit2都这些问题时如何解决的，这篇，我们就一起深入去了解一下。</p>
<h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><p>  一个网络连接需要构造请求，发送请求，处理服务端返回内容三个步骤组成，但是处理服务端返回内容是用库的人的工作，所以一个网络请求库只要做到前两步并将服务端返回内容转化为使用库的人需要的格式即可。</p>
<p>对于这三个步骤，两个版本的区别在于</p>
<h4 id="构造请求"><a href="#构造请求" class="headerlink" title="构造请求:"></a>构造请求:</h4><ol>
<li>Retrofit2新加了<code>@Url</code>注解。</li>
<li>新加了对某个请求单独加入Http请求头，<code>@Headers</code>(用于方法)/<code>@Header</code>(用于函数参数)。</li>
</ol>
<h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求:"></a>发送请求:</h4><ol>
<li>将网络请求交给了OkHttp</li>
</ol>
<h4 id="将服务端返回内容转化为你需要的格式"><a href="#将服务端返回内容转化为你需要的格式" class="headerlink" title="将服务端返回内容转化为你需要的格式:"></a>将服务端返回内容转化为你需要的格式:</h4><ol>
<li>Retrofit2将可以同时拿到返回内容的Header和Body，Retrofit1则不可以</li>
<li>使用Call返回值类型将同步和异步请求统一</li>
<li>可以添加多个Converter</li>
<li>可以添加多个返回值类型的解析机制，在Retrofit2中称为<code>CallAdapterFactory</code>使用<code>addCallAdapterFactory()</code></li>
</ol>
<p>我们接下来跟着官方的例子来看一下这些修改时如何实现的。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">    .baseUrl(<span class="string">"https://api.github.com/"</span>)</div><div class="line">    .addConverterFactory(GsonConverterFactory.create())</div><div class="line">    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</div><div class="line">    .build();</div><div class="line"></div><div class="line">GitHubService service = retrofit.create(GitHubService.class);</div><div class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">"octocat"</span>);</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</div><div class="line">  <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</div><div class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这里可以看出，通过<code>Retrofit</code>对象的<code>create()</code>方法创建出<code>GithubService</code>接口的实现，然后通过该实现进行网路请求，那么我们看看<code>create()</code>方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</div><div class="line">    Utils.validateServiceInterface(service);</div><div class="line">    <span class="keyword">if</span> (validateEagerly) &#123;</div><div class="line">      eagerlyValidateMethods(service);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), </div><div class="line">                        <span class="keyword">new</span> Class&lt;?&gt;[] &#123;service&#125;,<span class="keyword">new</span> InvocationHandler() &#123;</div><div class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</div><div class="line"></div><div class="line">          <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object... args)</span></span></div><div class="line">              <span class="keyword">throws</span> Throwable &#123;</div><div class="line">            <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></div><div class="line">            <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</div><div class="line">              <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</div><div class="line">              <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</div><div class="line">            &#125;</div><div class="line">            ServiceMethod serviceMethod = loadServiceMethod(method);</div><div class="line">            OkHttpCall okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">            <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>熟悉Retrofit1的同学可以看出这里有3点不同的地方，不熟悉也没关系，因为相同的地方就是验证接口的有效性和使用动态代理生成接口对应的实现类。接下来讲一下这三点不同。</p>
<ol>
<li>添加了<code>validateEagerly</code>参数，让客户端调用网络请求的时候不需要在反射生成的代理类中才进行初始化;提前初始化，提前验证接口是否合法，不需要在调用时才知道。</li>
<li>添加了一个暂时不用的方法，为以后使用做扩展<code>platform.isDefaultMethod(method)</code>。</li>
<li>将初始化过的方法交给<code>OkHttpCall</code>去执行，执行完后，通过设置的<code>CallAdapter</code>将返回值转化为你要的返回类型对象，当你通过该对象调用它的方法的时候，将把请求交给<code>OkHttp</code>去执行。</li>
</ol>
<p>分开来讲一下，先看第二点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDefaultMethod</span><span class="params">(Method method)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出这个方法压根就没有用，所以我不是很了解放在这里一个不需要的方法意义是什么。</p>
<p>再看第一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (validateEagerly) &#123;</div><div class="line">   eagerlyValidateMethods(service);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eagerlyValidateMethods</span><span class="params">(Class&lt;?&gt; service)</span> </span>&#123;</div><div class="line">  <span class="comment">//和Retrofit1一样，通过反射确定客户端的平台，使用不同的方式处理</span></div><div class="line">  Platform platform = Platform.get();</div><div class="line">  <span class="keyword">for</span> (Method method : service.getDeclaredMethods()) &#123;</div><div class="line">    <span class="keyword">if</span> (!platform.isDefaultMethod(method)) &#123;</div><div class="line">      loadServiceMethod(method);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//和Retrofit1一样，使用Map做了一个缓存，有的话直接取，</span></div><div class="line"><span class="comment">//否则遍历该方法的信息，创建ServiceMethod对象</span></div><div class="line"><span class="function">ServiceMethod <span class="title">loadServiceMethod</span><span class="params">(Method method)</span> </span>&#123;</div><div class="line">    ServiceMethod result;</div><div class="line">    <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</div><div class="line">      result = serviceMethodCache.get(method);</div><div class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">        result = <span class="keyword">new</span> ServiceMethod.Builder(<span class="keyword">this</span>, method).build();</div><div class="line">        serviceMethodCache.put(method, result);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看一下第三点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ServiceMethod serviceMethod = loadServiceMethod(method);</div><div class="line">   OkHttpCall okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">   <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</div></pre></td></tr></table></figure>
<p><code>serviceMethod.callAdapter.adapt()</code>方法将<code>Call</code>对象转化为你写的返回值类型对象，即你在接口中所需的除<code>Call&lt;T&gt;</code>类型外，都需要对应的<code>CallAdapter</code>来进行转化。<code>OkHttpCall</code>实现了<code>Call&lt;T&gt;</code>接口，也就是前一篇讲到的，加入了<code>Call&lt;T&gt;</code>返回值类型。默认的<code>CallAdapter</code>支持转化成<code>Call</code>类型对象，如果需要其他的类型，你就需要调用<code>addCallAdapterFactory()</code>方法来添加新类型了。然后通过<code>OkHttp</code>进行网络请求。</p>
<p>到这里大体上就讲完了，接下来就重新回到前面讲的，对一个网络请求的三个步骤进行分析，看看代码中具体是如何实现的（老规矩，忽视不重要的错误处理）。</p>
<h4 id="构造请求-1"><a href="#构造请求-1" class="headerlink" title="构造请求:"></a>构造请求:</h4><p>这一点的重点在<code>ServiceMethod</code>这个类，前面讲到了这个类初始化的地方，那么就从<br><code>new ServiceMethod.Builder(this, method).build()</code>开始。<br>构造函数就初始化了一些类变量，来看一下<code>build()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ServiceMethod <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">// </span></div><div class="line">    callAdapter = createCallAdapter();</div><div class="line">    <span class="comment">// 把函数返回值类型中泛型内的类型拿出来，</span></div><div class="line">    <span class="comment">// 比如接口方法中某个方法返回Call&lt;Repo&gt;，这个方法执行结果是Repo</span></div><div class="line">    responseType = callAdapter.responseType();</div><div class="line">    </div><div class="line">    responseConverter = createResponseConverter();</div><div class="line">    <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</div><div class="line">      <span class="comment">//解析定义的Http注解，如GET，HTTP，FormUrlEncoded，Multipart，Headers</span></div><div class="line">      <span class="comment">//如果存在Headers注解，Headers注解内的内容不能为空</span></div><div class="line">      parseMethodAnnotation(annotation);</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// parameterAnnotationsArrays = method.getParameterAnnotations(),</span></div><div class="line">	<span class="comment">// 即参数中的注解，二维注解数组Annotation[][]</span></div><div class="line">    <span class="keyword">int</span> parameterCount = parameterAnnotationsArray.length;</div><div class="line">    <span class="comment">// ParameterHandler这个类如名字所示，负责处理有注解的函数参数</span></div><div class="line">    parameterHandlers = <span class="keyword">new</span> ParameterHandler&lt;?&gt;[parameterCount];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; parameterCount; p++) &#123;</div><div class="line">      <span class="comment">// parameterType = method.getGenericParameterTypes()</span></div><div class="line">      Type parameterType = parameterTypes[p];</div><div class="line">      <span class="comment">// 这个方法就是检测方法参数类型是否是可以处理的类型</span></div><div class="line">      <span class="comment">// 这个方法可以学到如何遍历所有的参数类型，包括泛型类型参数</span></div><div class="line">	  <span class="keyword">if</span> (Utils.hasUnresolvableType(parameterType)) &#123;</div><div class="line">	            <span class="keyword">throw</span> parameterError(p, <span class="string">"Parameter type must not include a type variable or wildcard: %s"</span>,</div><div class="line">	                parameterType);</div><div class="line">	          &#125;</div><div class="line"></div><div class="line">      Annotation[] parameterAnnotations = parameterAnnotationsArray[p];</div><div class="line">      <span class="comment">// 这里处理Retrofit2定义的所有@Target(PARAMETER)的参数，返回对应的ParameterHandler</span></div><div class="line">      parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceMethod&lt;&gt;(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了<code>createCallAdapter()</code>，<code>createResponseConverter()</code>这两个方法，这两个方法我们一会再说，按名字理解就是创建<code>CallAdapter</code>和<code>ResponseConverter</code>，这两个东西的作用就是将方法的返回值转化成你要的。</p>
<p>剩下的关键方法都在方法中做了注释，这样，<code>ServiceMethod</code>类对象就生成了。<br>到了这里，先不继续进行，先看一下<code>parseMethodAnnotation(annotation)</code>方法中使用的<code>parseHttpMethodAndPath()</code>方法，这个方法中会做一些验证，这个验证个人觉得有些不好理解，所以放出源代码，并将注释写在方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseHttpMethodAndPath</span><span class="params">(String httpMethod, String value, <span class="keyword">boolean</span> hasBody)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.httpMethod = httpMethod;</div><div class="line">  <span class="keyword">this</span>.hasBody = hasBody;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (value.isEmpty()) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Get the relative URL path and existing query string, if present.</span></div><div class="line">  <span class="keyword">int</span> question = value.indexOf(<span class="string">'?'</span>);</div><div class="line">  <span class="keyword">if</span> (question != -<span class="number">1</span> &amp;&amp; question &lt; value.length() - <span class="number">1</span>) &#123;</div><div class="line">    <span class="comment">// Ensure the query string does not have any named parameters.</span></div><div class="line">    String queryParams = value.substring(question + <span class="number">1</span>);</div><div class="line">    Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);</div><div class="line">    <span class="keyword">if</span> (queryParamMatcher.find()) &#123;<span class="comment">// url中?之后的的String不允许存在"&#123;&#125;"</span></div><div class="line">      <span class="keyword">throw</span> methodError(<span class="string">"URL query string \"%s\" must not have replace block. "</span></div><div class="line">          + <span class="string">"For dynamic query parameters use @Query."</span>, queryParams);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.relativeUrl = value;</div><div class="line">  <span class="keyword">this</span>.relativeUrlParamNames = parsePathParameters(value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好了， 这点不好理解的地方也过去了。既然生成了<code>ServiceMethod</code>，那么我们继续往下看：<br>构造函数生成了<code>OkHttpCall</code>对象，最后，通过<code>ServiceMethod</code>的<code>CallAdapter</code>对象将<code>OkHttpCall</code>对象转化为你在网络请求接口中声明的返回值类型。</p>
<p>在这里，我们再看一下上面提到但没分析的那两个方法<code>createCallAdapter()</code>和<code>createResponseConverter()</code>。先看<code>createCallAdapter()</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> CallAdapter&lt;?&gt; createCallAdapter() &#123;</div><div class="line">  <span class="comment">// 返回方法声明的返回类型</span></div><div class="line">  Type returnType = method.getGenericReturnType();</div><div class="line">  </div><div class="line">  <span class="keyword">if</span> (returnType == <span class="keyword">void</span>.class) &#123;</div><div class="line">    <span class="keyword">throw</span> methodError(<span class="string">"Service methods cannot return void."</span>);</div><div class="line">  &#125;</div><div class="line">  Annotation[] annotations = method.getAnnotations();</div><div class="line">  <span class="keyword">return</span> retrofit.callAdapter(returnType, annotations);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法就获取了方法的返回值类型和方法的注解，最后调用<code>Retrofit</code>对象的<code>callAdapter()</code>方法找到对应的callAdapter，好了，我们继续,<br>retrofit对象的<code>callAdapter()</code>方法就一句代码，<code>return nextCallAdapter(null, returnType, annotations);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> CallAdapter&lt;?&gt; nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,</div><div class="line">    Annotation[] annotations) &#123;</div><div class="line">  checkNotNull(returnType, <span class="string">"returnType == null"</span>);</div><div class="line">  checkNotNull(annotations, <span class="string">"annotations == null"</span>);</div><div class="line">  <span class="comment">// List&lt;CallAdapter.Factory&gt; adapterFactories,你调用addCallAdapterFactory()就将你的CallAdapterFactory加入到了这个列表中</span></div><div class="line">  <span class="comment">//即使你不调用addCallAdapterFactory()方法，系统也会加入一个默认的CallAdapterFactory,就是在第一篇文章中提到的Call返回值类型。</span></div><div class="line">  <span class="keyword">int</span> start = adapterFactories.indexOf(skipPast) + <span class="number">1</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = adapterFactories.size(); i &lt; count; i++) &#123;</div><div class="line">    CallAdapter&lt;?&gt; adapter = adapterFactories.get(i).get(returnType, annotations, <span class="keyword">this</span>);</div><div class="line">    <span class="keyword">if</span> (adapter != <span class="keyword">null</span>) &#123; <span class="comment">// 如果返回值类型和adapter能处理的相同，则不为null</span></div><div class="line">      <span class="keyword">return</span> adapter;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"..."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里将注解传给<code>callAdapter()</code>是为了我们使用更好的扩展。<br>这个扩展具体指什么呢？前面我们提到，可以添加多个<code>Converter</code>和<code>CallAdapter</code>。<br>这里就是给你这样一种能力，如果你有自定义注解，在这里你就可以拿到自己定义的注解来处理。<br><code>callAdapter()</code>方法直接从<code>adapterFactories</code>列表中获取目标类型，即直接获取你需要该方法返回什么类型的值。<br>可以看到，这里就是找哪个<code>CallAdapter</code>可以处理用户声明的该方法返回值类型，这样一个<code>CallAdapter</code>对象就生成了。</p>
<p>接下来看看<code>createResponseConverter()</code>方法，在第一篇的介绍中提到<code>Converter</code>和<code>CallAdapter</code>类似，那么我猜测代码中的创建过程应该也是类似的，来仔细瞧一瞧是不是这样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Converter&lt;ResponseBody, T&gt; <span class="title">createResponseConverter</span><span class="params">()</span> </span>&#123;</div><div class="line">  Annotation[] annotations = method.getAnnotations();</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">return</span> retrofit.responseBodyConverter(responseType, annotations);</div><div class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></div><div class="line">    <span class="keyword">throw</span> methodError(e, <span class="string">"Unable to create converter for %s"</span>, responseType);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和上面一样，调用了retrofit对象的方法，<code>responseBodyConverter()</code>方法同样一句代码:<br><code>return nextResponseBodyConverter(null, type, annotations);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;ResponseBody, T&gt; <span class="title">nextResponseBodyConverter</span><span class="params">(Converter.Factory skipPast,</span></span></div><div class="line">    Type type, Annotation[] annotations) &#123;</div><div class="line">  checkNotNull(type, <span class="string">"type == null"</span>);</div><div class="line">  checkNotNull(annotations, <span class="string">"annotations == null"</span>);</div><div class="line">  <span class="comment">// List&lt;Converter.Factory&gt; converterFactories,你调用addConverterFactory()方法就是将你的Converter.Factory加入这个列表中，因为列表有序，所以从前往后找，JSON没有明显的特征，所以需要将JSON放在最后</span></div><div class="line">  <span class="comment">// 即使你不调用addConverterFactory()方法，会加入内置的Converter.Factory</span></div><div class="line">  <span class="comment">// 下面是加入内置Converter.Factory的方法和注释。</span></div><div class="line">   <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></div><div class="line">      <span class="comment">// ensures correct behavior when using converters that consume all types.</span></div><div class="line">      <span class="comment">// converterFactories.add(new BuiltInConverters());</span></div><div class="line">  <span class="keyword">int</span> start = converterFactories.indexOf(skipPast) + <span class="number">1</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = start, count = converterFactories.size(); i &lt; count; i++)&#123;</div><div class="line">    <span class="comment">//将ResponseBody转化为你需要的类型</span></div><div class="line">    Converter&lt;ResponseBody, ?&gt; converter =</div><div class="line">        converterFactories.get(i).responseBodyConverter(type, annotations, <span class="keyword">this</span>);</div><div class="line">    <span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123; <span class="comment">// 如果能处理对应的type，则不为null</span></div><div class="line">      <span class="comment">//noinspection unchecked</span></div><div class="line">      <span class="keyword">return</span> (Converter&lt;ResponseBody, T&gt;) converter;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"..."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了这个ResponseBodyConverter，还有一个RequestBodyConverter，其实这个也是从<code>converterFactories</code>里面寻找处理请求参数的Converter。</p>
<p>到这里，<code>Retrofit</code>对象的<code>create()</code>方法就分析完了，<code>CallAdapter</code>将<code>OkHttpCall</code>对象转化成了你想要的对象，此时就可以拿你想要的对象进行操作了，也就是构造请求完成了。</p>
<h4 id="发送请求-1"><a href="#发送请求-1" class="headerlink" title="发送请求:"></a>发送请求:</h4><p>当用户调用接口中方法的时候，底层直接通过OkHttp进行发送请求。</p>
<h4 id="将服务端返回内容转化为你需要的格式-1"><a href="#将服务端返回内容转化为你需要的格式-1" class="headerlink" title="将服务端返回内容转化为你需要的格式:"></a>将服务端返回内容转化为你需要的格式:</h4><p>OkHttp接收到请求后，通过<code>Converter</code>将服务端返回内容转化为你需要的格式。所以到这里源码的流程已经走完了。</p>
<p>可以看出其实这个框架在构造请求的完成的时候工作也完成了。</p>
<p>接下来有一些需要注意的地方:</p>
<ol>
<li>接口中任何一个方法的只允许被一个Http方法注解(即[GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS, HTTP]这个列表中的元素每个方法只能使用一个)</li>
<li>网络请求只要服务端有数据返回，就不算failure，Retrotfit1的时候404和500都算failure。所以当你使用Callback时，在<code>onResponse</code>函数里，使用<code>response.isSuccessful()</code>确定服务端返回正常数据还是服务端错误信息。</li>
<li>Url的拼接规则变了，初始化Retrofit对象的时候baseUrl最后一定要加’/‘。详细的内容查看下面的表格:</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">BaseUrl</th>
<th style="text-align:center">AnnotationUrl</th>
<th style="text-align:center">RequestUrl</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="https://api.github.com/repo/" target="_blank" rel="external">https://api.github.com/repo/</a></td>
<td style="text-align:center">/square/end</td>
<td style="text-align:center"><a href="https://api.github.com/square/end" target="_blank" rel="external">https://api.github.com/square/end</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="https://api.github.com/repo/" target="_blank" rel="external">https://api.github.com/repo/</a></td>
<td style="text-align:center">square/end</td>
<td style="text-align:center"><a href="https://api.github.com/repo/square/end" target="_blank" rel="external">https://api.github.com/repo/square/end</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="https://api.github.com/repo/" target="_blank" rel="external">https://api.github.com/repo/</a></td>
<td style="text-align:center"><a href="http://z.cn/end" target="_blank" rel="external">http://z.cn/end</a></td>
<td style="text-align:center"><a href="http://z.cn/end" target="_blank" rel="external">http://z.cn/end</a></td>
</tr>
</tbody>
</table>
<p>最后放一张流程图，来源[Retrofit分析-漂亮的解耦套路][2]，是一个很棒的流程图，可以加深对此源码分析的理解。</p>
<p><img src="/img/retrofit/retrofit2.png" alt=""></p>
<p>最后是一些参考资料:</p>
<ol>
<li><a href="http://www.jianshu.com/p/308f3c54abdd" target="_blank" rel="external">你真的会用Retrofit2吗?</a> 对Retrofit2中用到的注解进行了分类，可以让你更清晰的使用对应的注解；提供了自定义<code>ConverterFactory</code>和<code>CallAdapterFactory</code>的思路。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://air.com/2016/05/08/retrofit2.0源码解析(上)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Air">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Air Little Place">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/08/retrofit2.0源码解析(上)/" itemprop="url">Retrofit2源码分析-(上)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-08T00:00:00+08:00">
                2016-05-08
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/05/08/retrofit2.0源码解析(上)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2016/05/08/retrofit2.0源码解析(上)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​    千呼万唤始出来的Retrofit2.0正式版终于出来了，首先我们来看一看 Jake Wharton 的演讲，这次演讲主要讲了1.0版本的好处和问题，以及2.0版本的优势，对于好处，我们在1.0版本的使用过程中相信都已体会过了，在这里我就不重新提了，那么这第一篇就主要讲一下1.0版本的问题，和2.0在设计上是如何解决这些问题的。至于源代码的分析和对比将会放在第二篇中讲。</p>
<h3 id="Retrofit1-问题"><a href="#Retrofit1-问题" class="headerlink" title="Retrofit1 问题"></a>Retrofit1 问题</h3><ul>
<li>无法同时获取响应返回的原始数据，比如请求头或者请求的URL，和反序列化的响应返回的body。</li>
<li>如果你写了一个请求，有时同步执行，有时异步执行，你就需要写两个基本一样的请求。（如果使用RxJava可以实现，但是你要知道如何创建Observables）</li>
<li>converter的工作方式事实上稍微有点低效。</li>
<li>严重限制了我们把自定义类作为参数加入请求的能力。</li>
</ul>
<h3 id="Retrofit2"><a href="#Retrofit2" class="headerlink" title="Retrofit2"></a>Retrofit2</h3><h4 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h4><p>内置和OkHttp的<code>Call</code>类型一样语义的Call类型，不同的是它能做一些额外的事情，比如反序列化对象，相反OkHttp只返回原始的内容给你，这就是Retrofit2实现一个类似的<code>Call</code>而不是用OkHttp中的<code>Call</code>的原因。它是一个请求/响应对，每一个<code>Call</code>实例只能使用一次，它有Java的clone方法来创建新的实例（这个操作很廉价）。另一个巨大的好处是它把同步和异步的执行统一在了一起，这样就解决了Retrofit1中同步请求和异步请求要写两个的问题，同时，它可以被取消，这个是Retrofit1中不存在的特性。接下来我们看一下它的使用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</div><div class="line">	<span class="meta">@GET</span>(<span class="string">"/repos/&#123;owner&#125;/&#123;repo&#125;/contributors"</span>)</div><div class="line">	Call&lt;List&lt;Contributor&gt;&gt; repoContributors(</div><div class="line">  	<span class="meta">@Path</span>(<span class="string">"owner"</span>) String owner,</div><div class="line">  	<span class="meta">@Path</span>(<span class="string">"repo"</span>) String repo);</div><div class="line">	&#125;</div><div class="line">	Call&lt;List&lt;Contributor&gt;&gt; call =</div><div class="line">	gitHubService.repoContributors(<span class="string">"square"</span>, <span class="string">"retrofit"</span>)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="参数化Response对象"><a href="#参数化Response对象" class="headerlink" title="参数化Response对象"></a>参数化Response对象</h4><p>通过Response，你可以获取请求的元数据，包括 response code, message, 和headers。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Response</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">code</span><span class="params">()</span></span>;</div><div class="line">  <span class="function">String <span class="title">message</span><span class="params">()</span></span>;</div><div class="line">  <span class="function">Headers <span class="title">headers</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isSuccess</span><span class="params">()</span></span>; </div><div class="line">  <span class="function">T <span class="title">body</span><span class="params">()</span></span>;</div><div class="line">  <span class="function">ResponseBody <span class="title">errorBody</span><span class="params">()</span></span>; </div><div class="line">  com.squareup.okhttp.<span class="function">Response <span class="title">raw</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只有响应的Http code是200的情况下才会进行反序列化。如果响            应没有成功，我们不知道响应是什么类型。将回返回<code>ResponseBody</code>类型，它将Content-Type，Content-Length，还有原始的body进行了封装，让你可以对响应做出想要的处理。</p>
<h4 id="动态URL参数"><a href="#动态URL参数" class="headerlink" title="动态URL参数"></a>动态URL参数</h4><p>有这样一种情况，请求列表的时候通常都要给服务端传入page，告诉服务端你要第几页数据，如果服务端将page相关的信息放在了响应头中，比如下一页page是什么，总共有几页等等，甚至服务端返回你接下来需要请求的URL。例如Github的API，Retrofit1很难处理这种情况。我们有一个新的<code>@Url</code>注解，允许你在参数中传入Url。如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GET</span></div><div class="line">Call&lt;List&lt;Contributor&gt;&gt; repoContributorsPaginate(</div><div class="line">      <span class="meta">@Url</span> String url);</div></pre></td></tr></table></figure>
<h4 id="多样的，高效的Converters"><a href="#多样的，高效的Converters" class="headerlink" title="多样的，高效的Converters"></a>多样的，高效的Converters</h4><p>Retrofit1有一个Converter的问题，当然，对于大多数人来说这都不算是问题，但对于一个库来说，它就成了问题。考虑下面一种场景，服务端有两套API，只是返回值的类型不同，比如一个返回json，一个返回xml，可能是如下的url:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GET</span>(<span class="string">"/some/xml/endpoint"</span>)</div><div class="line"><span class="meta">@GET</span>(<span class="string">"/some/json/endpoint"</span>)</div></pre></td></tr></table></figure>
<p>在Retrofit1中，你不得不定义两个接口，初始化两个<code>RestAdapter</code>，因为它只有一个Converter，每一个Converter和一个<code>RestAdapter</code>绑定在一起，但是，我们认为这些操作同属于一组API，而不是分离的API，所以，API的返回类型不应该成为你组织<code>Service</code>的方式。</p>
<p>我们会按你添加的顺序来一个个的问Converter是否可以序列化该返回值，如果它的回答是yes，那么就交给该Converter来序列化返回值。</p>
<p>两点需要注意的地方:</p>
<ul>
<li>由于JSON没有任何要求或者限制，所以我们无法知道它是否可以被JSON Converter序列化，所以JSON Converter永远会回答yes，在这种情况下，JSON Converter应该是你添加的最后一个Converter。</li>
<li>和Retrofit1不同的是，Retrofit2本身提供内置的Converter，但是只是提供了三种基础的Converter，像Json之类的Converter不会内置，所以你需要明确的声明你所用的Converter。当然，我们提供了一些Converter，但是你需要把这些Converter作为独立的依赖加入项目中。</li>
</ul>
<h4 id="多种多样插件形式的执行机制"><a href="#多种多样插件形式的执行机制" class="headerlink" title="多种多样插件形式的执行机制"></a>多种多样插件形式的执行机制</h4><p>之前，我们只有死板的执行机制。现在我们把它弄成了插件形式的，它的工作方式和Covnerter类似。<br>你可以加入你自己的方式，或者选择一个我们提供的已有的方式，我们依旧提供RxJava这个执行方式，但是它和Retrofit2库分离，需要单独的引入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</div><div class="line">  <span class="meta">@GET</span>(<span class="string">"/repos/&#123;owner&#125;/&#123;repo&#125;/contributors"</span>)</div><div class="line">  Call&lt;List&lt;Contributor&gt;&gt; repoContributors(..);</div><div class="line"></div><div class="line">  <span class="meta">@GET</span>(<span class="string">"/repos/&#123;owner&#125;/&#123;repo&#125;/contributors"</span>)</div><div class="line">  Observable&lt;List&lt;Contributor&gt;&gt; repoContributors2(..);</div><div class="line"></div><div class="line">  <span class="meta">@GET</span>(<span class="string">"/repos/&#123;owner&#125;/&#123;repo&#125;/contributors"</span>)</div><div class="line">  Future&lt;List&lt;Contributor&gt;&gt; repoContributors3(..);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们单纯的查看返回类型，对于第一个函数来说，我们对执行机制的询问过程是这样的。<code>call —&gt; RxJava? No! —&gt; Call? Yes!</code></p>
<p>对于第三个Future,将会抛出一个异常，因为你没有加入你的执行机制，导致了执行机制无法执行。该过程是<code>Future —&gt; RxJava? No! —&gt; Call? No! —&gt; Throw!</code>。如果你想添加自己的执行机制，只要在初始化Retrofit对象的时候使用<code>addCallAdapterFactory()</code>，添加你自己的执行机制即可。</p>
<p>这个执行机制(Execution Mechanism)翻译到中文不是很合适，按我的理解，这个所谓的执行方式，就是生成的函数有个默认的返回值，但是返回值类型不一定是你需要的，所以，使用这个对象将生成函数的返回值转化成你需要的类型。</p>
<h4 id="由OkHttp提供底层技术支持"><a href="#由OkHttp提供底层技术支持" class="headerlink" title="由OkHttp提供底层技术支持"></a>由OkHttp提供底层技术支持</h4><p>就是说引入Retrofit2会默认引入OkHttp到你的项目中。</p>
<h4 id="极好的效率（这个我没找到相应的测试，只是Jake-Wharton在演讲中提到了）"><a href="#极好的效率（这个我没找到相应的测试，只是Jake-Wharton在演讲中提到了）" class="headerlink" title="极好的效率（这个我没找到相应的测试，只是Jake Wharton在演讲中提到了）"></a>极好的效率（这个我没找到相应的测试，只是Jake Wharton在演讲中提到了）</h4>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://air.com/2016/03/06/Android管理任务栈之——launchMode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Air">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Air Little Place">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/06/Android管理任务栈之——launchMode/" itemprop="url">Android管理任务栈之——launchMode</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-06T00:00:00+08:00">
                2016-03-06
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/03/06/Android管理任务栈之——launchMode/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2016/03/06/Android管理任务栈之——launchMode/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前遇到了一个问题，大概是有4个Activity，分别为A, B, C, D Activity，当你的Activity跳转, A -&gt; B -&gt; C -&gt; D 跳转，此时，你需要从D跳回B，不能把C<code>finish()</code>掉，因为用户中途可能会返回C，而不继续进行下一步操作；直接跳也不可以，因为默认情况下跳到B的时候，用户点返回会返回D而不是A，这个时候我知道了LaunchMode，发现这种情况很适合一个LaunchMode的使用 ———— <code>singleTask</code>，趁此机会，研究一下LaunchMode。</p>
<h2 id="LaunchMode-开篇"><a href="#LaunchMode-开篇" class="headerlink" title="LaunchMode 开篇"></a>LaunchMode 开篇</h2><p>说到LaunchMode，我们来看看官方文档怎么说 ：</p>
<blockquote>
<p>An instruction on how the activity should be launched. There are four modes that work in conjunction with activity flags (<code>FLAG_ACTIVITY_*</code> constants) in Intent objects to determine what should happen when the activity is called upon to handle an intent. They are:</p>
</blockquote>
<ul>
<li><p>“standard” </p>
</li>
<li><p>“singleTop” </p>
</li>
<li><p>“singleTask” </p>
</li>
<li><p>“singleInstance”</p>
<p>The default mode is “standard”.</p>
</li>
</ul>
<p>即Activity有4种启动模式，分别是</p>
<ul>
<li>“standard” </li>
<li>“singleTop” </li>
<li>“singleTask” </li>
<li>“singleInstance”</li>
</ul>
<p>这个需要在Manifest中指定。可以和Intent中的<code>FLAG_ACTIVITY_*</code>结合使用。</p>
<p>当然，我们要明确一点，Android中以栈的形式来管理<code>Activity</code>，至于什么是栈，请复习数据结构相关内容，这里假设大家都理解栈。</p>
<h2 id="四种模式各个模式的作用"><a href="#四种模式各个模式的作用" class="headerlink" title="四种模式各个模式的作用"></a>四种模式各个模式的作用</h2><p>先告诉大家一个方法，通过如下命令获取你当前包的<code>Activity</code>任务栈</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell dumpsys activity activities | sed -En -e '/Stack #/p' -e '/Running activities/,/Run #0/p' | grep "包名"</div></pre></td></tr></table></figure>
<ul>
<li>“standard”</li>
</ul>
<p>大家默认新建的<code>Activity</code>就是这个模式的，这个模式相当于不对<code>Activity</code>加任何约束，即你调用<code>intent.startActivity()</code>的时候，每调用一次，就会在栈中新加一个改<code>Activity</code>。</p>
<p>先看一下我们当前的任务栈：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Run #7: ActivityRecord&#123;ac97db9 u0 com.air.activitylaunchmodetestdemo/.MainActivity t1211&#125;</div></pre></td></tr></table></figure>
<p>可以看到，当前只有一个<code>MainActivity</code>，此时，当我点击按钮执行<code>startActivity(new Intent(this, MainActivity.class))</code>的时候，可以看到任务栈变成了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Run #8: ActivityRecord&#123;11e0192c u0 com.air.activitylaunchmodetestdemo/.MainActivity t1211&#125;</div><div class="line">Run #7: ActivityRecord&#123;ac97db9 u0 com.air.activitylaunchmodetestdemo/.MainActivity t1211&#125;</div></pre></td></tr></table></figure>
<p>因为没有在<code>startActivity()</code>之后执行<code>finish()</code>方法，现在我们有了两个<code>MainActivity</code>实例，此时如果退出应用，要点两次后退键才可以。如果我再次点击按钮执行<code>startActivity(new Intent(this, MainActivity.class))</code>的时候，可以想象新的任务栈该变成什么了。</p>
<p> 接下来我们以图的形式说明该LaunchMode情况下，任务栈的样子。</p>
<p> <img src="/img/launchMode/ActivityStack--standard.png" alt="ActivityStack--standard"></p>
<p>就像上图画的那样，每启动一个新的Activity，就会添加到栈上，无论即将启动的Activity是否是同一个Activity。</p>
<ul>
<li>“singleTop”</li>
</ul>
<p>看到这个名字，先靠命名理解一下，在顶部的时候是单一存在，因为是以栈的形式来管理<code>Activity</code>的，那么顶部指的就是栈的顶部。</p>
<p>好了，上面的猜测其实已经和真正的情况是差不多了，我在此再补充几点细节。对于不是栈顶的<code>Activity</code>，即使设置了这个launchMode，依旧会创建新的Activity。例如，存在两个<code>Activity</code>A、B，它们的launchMode都是singleTop，如果你在A中启动A，栈不会新添加<code>Activity</code>，因为此时A<code>Activity</code>在栈顶，但是，如果你用A启动B，B就会被加入到栈中，此时栈就变成了AB，再拿B启动A，会产生A的新实例添加到栈内，现在栈变成了ABA。</p>
<p>拿前面举的A<code>Activity</code>例子来说，在A中启动A，由于A在栈顶，所以栈内不会添加A的新实例，自然不会调用A的<code>onCreate()</code>方法，这个时候，如果启动A的时候给A传了额外的参数，那么需要在哪里处理呢？答案是<code>onNewIntent()</code>，这里就是singleTop和standard两种launchMode不同的地方。</p>
<p>常用场景：带搜索功能的<code>Activity</code>，搜索不同的关键词不用多次启动同一个<code>Activity</code>。</p>
<ul>
<li>“singleTask”</li>
</ul>
<p>上面介绍的两个launchMode的作用不能实现栈中只存在一个<code>Activity</code>实例，但是有些时候，就像我在开头举的那个例子，业务逻辑中间要跳好几层，最终只想跳到入口界面，即栈中只需要存在一个相应的<code>Activity</code>，而不是多个。</p>
<p>总结一个singleTask的作用，若一个<code>Activity</code>的launchMode被指定为singleTask，则在对应的栈中只会存在一个实例。若这个实例不存在，则新建实例；若存在，则把在栈中该实例之上的其他实例移除出栈，并调用该<code>Activity</code>的<code>onNewIntent()</code>方法，将intent传入。 </p>
<p><img src="/img/launchMode/ActivityStack--singleTop.png" alt="ActivityStack--singleTop"></p>
<p>我们来通过代码验证一下：启动了四个<code>Activity</code>，</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Run #7: ActivityRecord&#123;b53e419 u0 com.air.activitylaunchmodetestdemo/.BActivity t3909&#125;</div><div class="line">Run #6: ActivityRecord&#123;7a83deb u0 com.air.activitylaunchmodetestdemo/.AActivity t3909&#125;</div><div class="line">Run #5: ActivityRecord&#123;df9c4ad u0 com.air.activitylaunchmodetestdemo/.CActivity t3909&#125;</div><div class="line">Run #4: ActivityRecord&#123;e7c438 u0 com.air.activitylaunchmodetestdemo/.MainActivity t3909&#125;</div></pre></td></tr></table></figure>
<p>CActivity为launchMode为singleTask的<code>Activity</code>，此时，从BActivity启动CActivity，通过前面的介绍，我们猜测会调用CActivity的<code>onNewIntent()</code>方法，并且，在栈中，CActivity之上的<code>Activity</code>都会被移除，此时，执行<code>startActivity()</code>方法，最新的栈内容如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Run #5: ActivityRecord&#123;df9c4ad u0 com.air.activitylaunchmodetestdemo/.CActivity t3909&#125;</div><div class="line">Run #4: ActivityRecord&#123;e7c438 u0 com.air.activitylaunchmodetestdemo/.MainActivity t3909&#125;</div></pre></td></tr></table></figure>
<p>可以看出，确实是我们所介绍的效果。至于设置taskAffinity后该launchMode的表现，我们在这篇文章中不会涉及，留到下一篇文章再与大家见面。</p>
<p>常用场景：注册Activity或者启动应用的首个<code>Activity</code>，这样就不用担心任务栈内有其他的<code>Activity</code>没有销毁了。</p>
<ul>
<li>“singleInstance”</li>
</ul>
<p>这个或许可以称之为singleTask模式的加强版，对于设置了singleTask的<code>Activity</code>，我们可以让它加入到在我们当前的任务栈中，也可以新建一个任务栈，把它放入(设置taskAffinity的情况下)。但是，对于singleInstance的<code>Activity</code>，我们只能新建一个任务栈，并把它放入，没有任何<code>Activity</code>可以和它在一个栈中。</p>
<p> 那么对于我们开发的应用，其中有一个<code>Activity</code>需要给其他应用使用，比如浏览器，你从自己的应用点开一个链接，使用浏览器应用开启网页，你单机后退，直接退到了你的应用，而不是你之前浏览的其他页面，如果你在浏览器中访问的连接可以访问你的应用，那么，此时点击后退你会发现，居然在你应用所在的栈中进行了回退操作，而不是退到浏览器页面，然后你退出应用，发现这个时候反倒打开了浏览器页面，这样说有点绕，我们以图的形势来展示一下。</p>
<p><img src="/img/launchMode/ActivityStack--singleInstance.png" alt="ActivityStack--singleInstance"></p>
<p>至于常用场景，我本以为支付、分享之类的很可能会使用，但是我反编译微信查看其manifest文件的时候，发现它并没有使用这个launchMode，所以暂时这里空着，如果你有什么使用场景，可以给我留言。</p>
<p>参考文章：</p>
<ol>
<li><a href="http://developer.android.com/guide/topics/manifest/activity-element.html#lmode" target="_blank" rel="external">官方文档</a></li>
<li><a href="http://droidyue.com/blog/2015/08/16/dive-into-android-activity-launchmode/" target="_blank" rel="external">深入讲解 Android 中的 Activity launchMode</a></li>
</ol>
<p>参考书籍：</p>
<ol>
<li>《第一行代码》</li>
<li>《Android开发艺术探索》</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://air.com/2016/01/16/Retrofit_1.9源码分析-(下)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Air">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Air Little Place">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/16/Retrofit_1.9源码分析-(下)/" itemprop="url">Retrofit-1.9源码分析-(下)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-16T00:00:00+08:00">
                2016-01-16
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/01/16/Retrofit_1.9源码分析-(下)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2016/01/16/Retrofit_1.9源码分析-(下)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>看过上一篇的分析，并思考了我在最后留给大家的对那个方法的思考之后，我们就可以继续解析这个库了。</p>
<p>记得上一篇提到的小尾巴吗？这里我们先不谈这个小尾巴，先从Demo里接口里面的定义开始谈。</p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</div><div class="line">    <span class="comment">//被注释的内容是同步方法，在Android 4.0以后不允许主线程进行网络请求，所以一般不这么用</span></div><div class="line">    <span class="comment">//@GET("/users/&#123;user&#125;/repos")</span></div><div class="line">    <span class="comment">//List&lt;Repo&gt; listRepos(@Path("user") String user);</span></div><div class="line">    <span class="meta">@GET</span>(<span class="string">"/users/&#123;user&#125;/repos"</span>)</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">listRepos</span><span class="params">(@Path(<span class="string">"user"</span>)</span> String user, Callback&lt;List&lt;Repo&gt;&gt; callback)</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里我们看到使用注解定义进行http请求时所需要的各种信息，比如相对url，参数等等。<br>那我们就先观察一下注解。这里使用了<code>@GET</code>注解，表示HTTP中的GET方法，</p>
<h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Make a GET request to a REST path relative to base URL. */</span></div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Target</span>(METHOD)</div><div class="line"><span class="meta">@Retention</span>(RUNTIME)</div><div class="line"><span class="meta">@RestMethod</span>(<span class="string">"GET"</span>)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GET &#123;</div><div class="line">  <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注解基础就不在这里讲了，这个<code>@GET</code>注解又被<code>@RestMethod</code>注解注解了，我们来看一下。</p>
<h4 id="RestMethod"><a href="#RestMethod" class="headerlink" title="RestMethod"></a>RestMethod</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Target</span>(ANNOTATION_TYPE)</div><div class="line"><span class="meta">@Retention</span>(RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RestMethod &#123;</div><div class="line">  <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">hasBody</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是注解注解的注解，也就是所谓的元注解。所有被这个注解注解的注解都可以被认为是该类型，<br>可以当作所有子类都可以被转换为父类。</p>
<p>被这个元注解注解的注解有这么几个, <code>@GET</code>, <code>@POST</code>, <code>@PUT</code>, <code>@PATCH</code>, <code>@DELETE</code>, <code>@DELETE</code>,<br>可以看出，这就是进行HTTP请求的几种常用的请求方式。</p>
<p>在示例中出现的其他注解先放一下。有了注解，那要实现这些注解的解析方式，这个实现在<code>RestMethodInfo.java</code>中<br>这里有两个重要方法来处理自定义的注解：<br>第一种是用在方法上的注解，如<code>@GET</code>，由<code>parseMethodAnnotations()</code>方法实现，<br>第二种是用在参数内的注解，如<code>@PATH</code>，由<code>parseParameters()</code>实现，</p>
<p>在这两个方法中，你可以知道哪些注解可以用在方法上，哪些注解可以用在参数内。</p>
<p>好了，到这里，我们终于可以返回上一篇最后留下的坑继续看了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), </div><div class="line">    <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</div><div class="line">    <span class="keyword">new</span> RestHandler(getMethodInfoCache(service)));</div></pre></td></tr></table></figure>
<h3 id="完成接口代理的创建"><a href="#完成接口代理的创建" class="headerlink" title="完成接口代理的创建"></a>完成接口代理的创建</h3><p>最终，<code>RestHandler</code>实现了<code>InvocationHandler</code>，对接口中的方法进行加工。</p>
<p>看名字应该也很容易理解，<code>getMethodInfoCache()</code>的意义就是从传入的接口中获取对应的相关方法的缓存，<br>用户定义的接口中每个<code>Method</code>都要和<code>RestMethodInfo</code>对应，自然想到使用<code>Map</code>做它们关系的联结。<br><code>RestHandler</code>持有对应的<code>Map</code>。<br>来看一下<code>InvocationHandler</code>接口中必须实现的唯一的方法：</p>
<h4 id="RestHandler-invoke"><a href="#RestHandler-invoke" class="headerlink" title="RestHandler.invoke()"></a>RestHandler.invoke()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) <span class="comment">//</span></div><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, <span class="keyword">final</span> Object[] args)</span></span></div><div class="line">    <span class="keyword">throws</span> Throwable &#123;</div><div class="line">  <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></div><div class="line">  <span class="comment">//Object类方法，直接执行，不需要做额外操作</span></div><div class="line">  <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</div><div class="line">    <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Load or create the details cache for the current method.</span></div><div class="line">  <span class="keyword">final</span> RestMethodInfo methodInfo = getMethodInfo(methodDetailsCache, method);</div><div class="line"></div><div class="line">  <span class="comment">//同步方法的处理逻辑，作为Android库的话忽视就可以了</span></div><div class="line">  <span class="keyword">if</span> (methodInfo.isSynchronous) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">return</span> invokeRequest(requestInterceptor, methodInfo, args);</div><div class="line">    &#125; <span class="keyword">catch</span> (RetrofitError error) &#123;</div><div class="line">      Throwable newError = errorHandler.handleError(error);</div><div class="line">      <span class="keyword">if</span> (newError == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Error handler returned null for wrapped exception."</span>,</div><div class="line">            error);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">throw</span> newError;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (httpExecutor == <span class="keyword">null</span> || callbackExecutor == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Asynchronous invocation requires calling setExecutors."</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//这个RestMethodInfo类中的类变量，通过你接口中方法定义来确认</span></div><div class="line">  <span class="keyword">if</span> (methodInfo.isObservable) &#123;</div><div class="line">    <span class="keyword">if</span> (rxSupport == <span class="keyword">null</span>) &#123; </div><div class="line">      <span class="keyword">if</span> (Platform.HAS_RX_JAVA) &#123;  <span class="comment">//和前面hasOkHttpOnClasspath()方法类似，就是找对应的包名</span></div><div class="line">        rxSupport = <span class="keyword">new</span> RxSupport(httpExecutor, errorHandler, requestInterceptor);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Observable method found but no RxJava on classpath."</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//rxSupport是一个自定义的类，查看这个方法的源码应该可以提升你对任意对象转换成Observable对象的理解</span></div><div class="line">    <span class="keyword">return</span> rxSupport.createRequestObservable(<span class="keyword">new</span> RxSupport.Invoker() &#123;</div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> ResponseWrapper <span class="title">invoke</span><span class="params">(RequestInterceptor requestInterceptor)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (ResponseWrapper) invokeRequest(requestInterceptor, methodInfo, args);</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Apply the interceptor synchronously, recording the interception so we can replay it later.</span></div><div class="line">  <span class="comment">// This way we still defer argument serialization to the background thread.</span></div><div class="line">  <span class="keyword">final</span> RequestInterceptorTape interceptorTape = <span class="keyword">new</span> RequestInterceptorTape();</div><div class="line">  requestInterceptor.intercept(interceptorTape);</div><div class="line"></div><div class="line">  Callback&lt;?&gt; callback = (Callback&lt;?&gt;) args[args.length - <span class="number">1</span>];</div><div class="line">  <span class="comment">//线程池执行网络请求，callbackExecutor指定callback执行的线程</span></div><div class="line">  httpExecutor.execute(<span class="keyword">new</span> CallbackRunnable(callback, callbackExecutor, errorHandler) &#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> ResponseWrapper <span class="title">obtainResponse</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> (ResponseWrapper) invokeRequest(interceptorTape, methodInfo, args);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// Asynchronous methods should have return type of void.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不得不说这个代码的注释写的真好，我针对其中的一部分代码写了中文注释。这里<code>invokeRequest()</code>方法很复杂，下面我们来看一下。</p>
<h4 id="RestHandler-invokeRequest"><a href="#RestHandler-invokeRequest" class="headerlink" title="RestHandler.invokeRequest()"></a>RestHandler.invokeRequest()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Execute an HTTP request.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@return</span> HTTP response object of specified &#123;<span class="doctag">@code</span> type&#125; or &#123;<span class="doctag">@code</span> null&#125;.</div><div class="line"> * <span class="doctag">@throws</span> RetrofitError if any error occurs during the HTTP request.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">invokeRequest</span><span class="params">(RequestInterceptor requestInterceptor, RestMethodInfo methodInfo,</span></span></div><div class="line">    Object[] args) &#123;</div><div class="line">  String url = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    methodInfo.init(); <span class="comment">// Ensure all relevant method information has been loaded.</span></div><div class="line"></div><div class="line">    String serverUrl = server.getUrl();</div><div class="line">    RequestBuilder requestBuilder = <span class="keyword">new</span> RequestBuilder(serverUrl, methodInfo, converter);</div><div class="line">    <span class="comment">//在这个方法内，将你放入该方法中的各个参数处理成http标准格式</span></div><div class="line">    requestBuilder.setArguments(args);</div><div class="line">    <span class="comment">//给http请求添加额外的信息，这些信息在requestBuilder写好了</span></div><div class="line">    <span class="comment">//自己在初始化RestAdapter的时候也可以初始化自己的RequestInterceptor，</span></div><div class="line">    <span class="comment">//这样的话就可以为一群http请求添加共同的header也好，参数也好</span></div><div class="line">    requestInterceptor.intercept(requestBuilder);</div><div class="line">    <span class="comment">//封装了一个HTTP请求所有需要的信息</span></div><div class="line">    Request request = requestBuilder.build();</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">long</span> start = System.nanoTime();</div><div class="line">    <span class="comment">//使用之前设置的Client.Provider进行网络请求，并得到返回值</span></div><div class="line">    <span class="comment">//Response这个类封装了HTTP返回信息</span></div><div class="line">    Response response = clientProvider.get().execute(request);</div><div class="line">    <span class="keyword">long</span> elapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> statusCode = response.getStatus();</div><div class="line">    <span class="comment">//就是指接口中方法的返回值类型</span></div><div class="line">    Type type = methodInfo.responseObjectType;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (statusCode &gt;= <span class="number">200</span> &amp;&amp; statusCode &lt; <span class="number">300</span>) &#123; <span class="comment">// 2XX == successful request</span></div><div class="line">      <span class="comment">//我们一般都要Convert之后的格式, 我还没遇到直接需要Response的情况，</span></div><div class="line">      <span class="comment">// Caller requested the raw Response object directly.</span></div><div class="line">      <span class="keyword">if</span> (type.equals(Response.class)) &#123;</div><div class="line">        <span class="keyword">if</span> (!methodInfo.isStreaming) &#123;</div><div class="line">          <span class="comment">//如果你返回值是Response，并且不返回流，而返回原始类型，</span></div><div class="line">          <span class="comment">//response会将服务端返回值写入一个64K大小的数组中，如果返回值很大，那么数据就无法完全储存，所以在这种情况下返回大文件会有问题</span></div><div class="line">          <span class="comment">// Read the entire stream and replace with one backed by a byte[].</span></div><div class="line">          response = Utils.readBodyToBytesIfNecessary(response);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (methodInfo.isSynchronous) &#123;</div><div class="line">          <span class="keyword">return</span> response;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseWrapper(response, response);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//这个接口的注释 Binary data with an associated mime type.</span></div><div class="line">      <span class="comment">//这个接口用来抽象http的返回值的body</span></div><div class="line">      TypedInput body = response.getBody();</div><div class="line">      <span class="keyword">if</span> (body == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (methodInfo.isSynchronous) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//这个就是callback里的Response和Body</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseWrapper(response, <span class="keyword">null</span>);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      ExceptionCatchingTypedInput wrapped = <span class="keyword">new</span> ExceptionCatchingTypedInput(body);</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//调用我们之前定义的Converter来解析数据</span></div><div class="line">        Object convert = converter.fromBody(wrapped, type);</div><div class="line">        logResponseBody(body, convert);</div><div class="line">        <span class="keyword">if</span> (methodInfo.isSynchronous) &#123;</div><div class="line">          <span class="keyword">return</span> convert;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseWrapper(response, convert);</div><div class="line">      &#125; <span class="keyword">catch</span> (ConversionException e) &#123;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//将body的数据转换成byte数组, http状态码不在200-300之间</span></div><div class="line">    response = Utils.readBodyToBytesIfNecessary(response);</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法很长，我去掉了<code>profiler</code>和<code>log</code>以及错误处理相关的内容。</p>
<p>这里首先调用的就是<code>method.init()</code>方法，这个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (loaded) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">  parseMethodAnnotations();</div><div class="line">  parseParameters();</div><div class="line"></div><div class="line">  loaded = <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果执行过，直接从缓存Map里拿就可以了，不需要重复执行，<br>这个方法就是前面说的，获取每个方法对应的注解和方法参数内的注解，并给你的那些方法做合理的替换。</p>
<p>剩下的方法基本都已做了注释，看代码即可了解。再提示一点，有<code>TypedInput</code>，自然有<code>TypedOutput</code>，<br><code>TypedOutput</code>的作用就和大家想的一样，是发送出去的数据类型的接口抽象。</p>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>在这里进行几点提示：</p>
<ol>
<li>自定义converter的时候需要实现<code>Converter</code>接口，比如你想用其它的Json解析库替代Gson，或者服务端返回值不是Json，而是XML等等。<br>只要了解了<code>TypedInput</code>和<code>TypedOutput</code>，剩下的很容易就可以完成了。</li>
<li>Retrofit这个版本不支持Multimap，所以如果服务端要求请求的时候key一样value不一样就很悲剧，那么修改RequestBuilder就可以达到Multimap的目的。</li>
<li>Retrofit这个版本不支持在接口中写入整个url，如果endpoint不一样就要重新创建一个<code>RestAdapter</code>，但悲剧的是创建一个<code>RestAdapter</code>的代价是很大的，<br>那么修改RestMethodInfo就可以达到在HTTP方法注解中使用整个url的目的。</li>
</ol>
<p>到这里我们对这个库的源码分析就完了，接下来以一副图来结束这个专题。</p>
<p><img src="/img/retrofit/retrofit1.9.png" alt=""></p>
<p>这样看来，Retrofit本身就是一个胶水层，同时像插槽一样留出一些插口给大家使用，简化了网络请求。</p>
<p>参考: <a href="http://www.cnblogs.com/angeldevil/p/3757335.html" target="_blank" rel="external">快速Android开发系列网络篇之Retrofit</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://air.com/2016/01/13/Retrofit-1.9源码分析-(上)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Air">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Air Little Place">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/13/Retrofit-1.9源码分析-(上)/" itemprop="url">Retrofit-1.9源码分析-(上)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-13T00:00:00+08:00">
                2016-01-13
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/01/13/Retrofit-1.9源码分析-(上)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2016/01/13/Retrofit-1.9源码分析-(上)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://github.com/square/retrofit" target="_blank" rel="external">Retrofit项目的GitHub</a></p>
<p>Retrofit 官网介绍Type-safe HTTP client for Android and Java。</p>
<p>接下来的这几篇文章的分析都是基于1.9版本的。</p>
<p>看过我前面文章的开发者们应该知道，我不喜欢把一篇文章写的很长，所以这个分析依旧会有好几篇，好了，我们开始第一篇的分析。</p>
<p>看到一个库，我们要首先会用，然后再去深入其中，研究其中的源代码。</p>
<p>那我们来看看这个库的用法。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>官网上的教程是这样写的。</p>
<p>首先定义请求接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</div><div class="line">    <span class="comment">//被注释的内容是同步方法，在Android 4.0以后不允许主线程进行网络请求，所以一般不这么用</span></div><div class="line">    <span class="comment">//@GET("/users/&#123;user&#125;/repos")</span></div><div class="line">    <span class="comment">//List&lt;Repo&gt; listRepos(@Path("user") String user);</span></div><div class="line">    <span class="meta">@GET</span>(<span class="string">"/users/&#123;user&#125;/repos"</span>)</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">listRepos</span><span class="params">(@Path(<span class="string">"user"</span>)</span> String user, Callback&lt;List&lt;Repo&gt;&gt; callback)</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后初始化<code>RestAdapter</code>，并且通过RestAdapter生成刚才代理的实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">RestAdapter restAdapter = <span class="keyword">new</span> RestAdapter.Builder()</div><div class="line">    .setEndpoint(<span class="string">"https://api.github.com"</span>)</div><div class="line">    .build();</div><div class="line"></div><div class="line">GitHubService service = restAdapter.create(GitHubService.class);</div></pre></td></tr></table></figure>
<p>现在就可以调用接口发送请求了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">service.listRepos(<span class="string">"octocat"</span>, <span class="keyword">new</span> Callback&lt;List&lt;Repo&gt;&gt;()&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">(List&lt;Repo&gt; repos, Response response)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failure</span><span class="params">(RetrofitError error)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这样就返回了网络请求对应的Model，并且通过回调让返回的结果在主线程进行操作，</p>
<p>从网络请求返回的数据到对应的Model转换是在<code>RestAdapter</code>那里定义的，默认是<code>Gson</code>解析，即默认服务端返回格式是Json，</p>
<p>当然你也可以使用不一样的Json解析库，当服务端返回Xml，Protocol Buffer的时候，你也可以解析，只要自己实现Converter接口，并在<code>RestAdapter</code>中设置即可。</p>
<p>这里有一个问题，如果服务端的接口不是全部返回一个格式怎么办？或者不是同一个Endpoint怎么办？每一个都需要定义一个对应的<code>RestAdapter</code>对应。</p>
<p>所以这里可能出现的问题就是，某些接口可能数据很简单，但是返回格式不统一，那么就需要新写一个这样类似的模板代码。</p>
<p>这样，我们大概了解了这个版本的库使用方式：</p>
<ol>
<li><p>定义一个接口，通过注解说明它是什么请求类型，并且在注解内写明它的相对于Endpoint(2.0版本称作BaseUrl,这样就好理解多了)的Url，</p>
<p>然后声明一个方法，这个方法中的参数就是网络请求时服务端需要的参数，也可以把网络请求的路径作为方法参数，最后定义一个回调，让返回结果在主线程中执行。</p>
</li>
<li><p>定义<code>RestAdapter</code>，并对其进行必要的设置，通过它生成那个接口对应的实现类。</p>
</li>
<li><p>调用实现类，执行网络请求。</p>
</li>
</ol>
<p>可以看出，定义<code>RestAdapter</code>是其中很重要的一步，那么我们先来分析它到底做了什么。</p>
<h3 id="初始化RestAdapter"><a href="#初始化RestAdapter" class="headerlink" title="初始化RestAdapter"></a>初始化RestAdapter</h3><p>我们看到示例，通过<code>Builder</code>来初始化的，那么源码中一定用了建造着模式，一般情况下，如果可设置项不多，不会用这样一个模式，</p>
<p>看来<code>RestAdapter</code>的可设置项非常多，我们来看看。</p>
<p>在<code>RestAdapter</code>内部的静态<code>Builder</code>类中，有这么多可以设置的内容。</p>
<h4 id="RestAdapter-Builder"><a href="#RestAdapter-Builder" class="headerlink" title="RestAdapter.Builder"></a>RestAdapter.Builder</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Endpoint endpoint;  <span class="comment">//就是BaseUrl，</span></div><div class="line"><span class="keyword">private</span> Client.Provider clientProvider; <span class="comment">//最终执行网络请求使用的库</span></div><div class="line"><span class="keyword">private</span> Executor httpExecutor;  <span class="comment">//http线程池的具体实现</span></div><div class="line"><span class="keyword">private</span> Executor callbackExecutor; <span class="comment">//callback在哪个线程执行</span></div><div class="line"><span class="keyword">private</span> RequestInterceptor requestInterceptor; <span class="comment">//网络请求的拦截者，可以给网络请求加入共同的参数</span></div><div class="line"><span class="keyword">private</span> Converter converter; <span class="comment">//网络请求返回值的解析方式(Json/Xml)</span></div><div class="line"><span class="keyword">private</span> Profiler profiler;   <span class="comment">//可以记录HTTP方法执行时间和状态码</span></div><div class="line"><span class="keyword">private</span> ErrorHandler errorHandler; <span class="comment">//错误处理</span></div><div class="line"><span class="keyword">private</span> Log log; </div><div class="line"><span class="keyword">private</span> LogLevel logLevel = LogLevel.NONE;</div></pre></td></tr></table></figure>
<p>如果分别深入每个类，那么，除了最后的LogLevel是enum之外，其他都是接口，有多少开发者还记得面向接口编程，不面向实现编程，</p>
<p>或者说作为开发者的我们记得这句话，但是自己实现的时候都忘记了。</p>
<p>其实这些接口就是一个个hook，留给使用者去自定义。但是这个库也提供了默认的参数，那这个默认的参数在哪里设置呢？</p>
<p>看回我们前面的例子，对于建造着模式，最后一步要使用<code>build()</code>方法来返回一个对应的类，那么我们来看一下这个<code>build()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Create the &#123;<span class="doctag">@link</span> RestAdapter&#125; instances. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> RestAdapter <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (endpoint == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Endpoint may not be null."</span>);</div><div class="line">      &#125;</div><div class="line">      ensureSaneDefaults();</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RestAdapter(endpoint, clientProvider, httpExecutor, callbackExecutor,</div><div class="line">          requestInterceptor, converter, profiler, errorHandler, log, logLevel);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里很容易可以看出，必须要设置EndPoint才能继续使用。</p>
<p>那么其它的类变量一定在<code>ensureSaneDefaults()</code>方法初始化了，否则当库的使用者未设置的时候，其它都是<code>null</code>了。</p>
<p>我们来看一下它的源码：</p>
<h4 id="RestAdapter-ensureSaneDefaults"><a href="#RestAdapter-ensureSaneDefaults" class="headerlink" title="RestAdapter ensureSaneDefaults()"></a>RestAdapter ensureSaneDefaults()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureSaneDefaults</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</div><div class="line">      converter = Platform.get().defaultConverter(); </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (clientProvider == <span class="keyword">null</span>) &#123;</div><div class="line">      clientProvider = Platform.get().defaultClient();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (httpExecutor == <span class="keyword">null</span>) &#123;</div><div class="line">      httpExecutor = Platform.get().defaultHttpExecutor();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</div><div class="line">      callbackExecutor = Platform.get().defaultCallbackExecutor();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (errorHandler == <span class="keyword">null</span>) &#123;</div><div class="line">      errorHandler = ErrorHandler.DEFAULT;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (log == <span class="keyword">null</span>) &#123;</div><div class="line">      log = Platform.get().defaultLog();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (requestInterceptor == <span class="keyword">null</span>) &#123;</div><div class="line">      requestInterceptor = RequestInterceptor.NONE;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，主要需要关心的接口都是由<code>Platform</code>类实现的，那我们进入其中一探究竟。</p>
<h4 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Platform</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Platform PLATFORM = findPlatform();</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">static</span> Platform <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> PLATFORM;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Platform <span class="title">findPlatform</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        Class.forName(<span class="string">"android.os.Build"</span>);</div><div class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT != <span class="number">0</span>) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">new</span> Android();</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (System.getProperty(<span class="string">"com.google.appengine.runtime.version"</span>) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppEngine();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Base();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>想要初始化它们，先使用<code>Platform.get()</code>方法，这个方法获取了单例<code>Platform</code>对象PLATFORM，这里给了我们实现单例的一种思路。</p>
<p>通过<code>findPlatform()</code>方法，如果是Android平台，则使用内部的<code>Android</code>子类，如果是Google AppEngine，则使用内部的<code>AppEngine</code>子类，</p>
<p>如果都不是，则使用内部的<code>Base</code>子类，还记得这个库的目标吧？是Java和Android平台的HTTP库，所以这里还可能是Java平台，所以要使用另外一种实现方式。</p>
<p>这次分析主要针对Android平台，所以如果好奇另外两个实现，请自己查看源码。</p>
<p>还记得我们在使用<code>RestAdapter</code>的<code>Builder</code>的时候除了<code>Endpoint</code>之外的接口吗？在<code>Platform</code>内部，定义了其它默认的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">abstract</span> Converter <span class="title">defaultConverter</span><span class="params">()</span></span>;</div><div class="line"><span class="keyword">abstract</span> Client.<span class="function">Provider <span class="title">defaultClient</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">abstract</span> Executor <span class="title">defaultHttpExecutor</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">abstract</span> Executor <span class="title">defaultCallbackExecutor</span><span class="params">()</span></span>;</div><div class="line"><span class="keyword">abstract</span> RestAdapter.<span class="function">Log <span class="title">defaultLog</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<p>均是抽象方法，意味着这些都要靠子类实现，那么我们看一下<code>Android</code>子类是如何实现的：</p>
<h4 id="Platform-Android"><a href="#Platform-Android" class="headerlink" title="Platform.Android"></a>Platform.Android</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function">Converter <span class="title">defaultConverter</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> GsonConverter(<span class="keyword">new</span> Gson()); <span class="comment">//默认Gson，处理请求返回的Json</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> Client.<span class="function">Provider <span class="title">defaultClient</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">final</span> Client client;</div><div class="line">      <span class="keyword">if</span> (hasOkHttpOnClasspath()) &#123;     <span class="comment">//存在Okhttp库，当然用OkHttp了</span></div><div class="line">        client = OkClientInstantiator.instantiate();</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.GINGERBREAD) &#123;</div><div class="line">        client = <span class="keyword">new</span> AndroidApacheClient();  <span class="comment">//Android 2.3以下用HttpClient</span></div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        client = <span class="keyword">new</span> UrlConnectionClient(); <span class="comment">//Android 2.3以上用HttpUrlConnection</span></div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Client.Provider() &#123;</div><div class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Client <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">          <span class="keyword">return</span> client;</div><div class="line">        &#125;</div><div class="line">      &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function">Executor <span class="title">defaultHttpExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> Executors.newCachedThreadPool(<span class="keyword">new</span> ThreadFactory() &#123; <span class="comment">//使用CachedThreadPool来管理网络请求</span></div><div class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">              Process.setThreadPriority(THREAD_PRIORITY_BACKGROUND); <span class="comment">//给线程设置优先级</span></div><div class="line">              r.run();</div><div class="line">            &#125;</div><div class="line">          &#125;, RestAdapter.IDLE_THREAD_NAME);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function">Executor <span class="title">defaultCallbackExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MainThreadExecutor();  <span class="comment">//callback在主线程执行</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> RestAdapter.<span class="function">Log <span class="title">defaultLog</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> AndroidLog(<span class="string">"Retrofit"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这里<code>hasOkHttpOnClasspath()</code>方法我觉得很棒，和前面找对应的平台一样，通过<code>Class.forName(包名)</code>找类，看是否存在。</p>
<p>如果自己写一个库的时候是好用的一种方式，支持一些新的东东。放一下它的源码。</p>
<h4 id="Platform-hasOkHttpOnClasspath"><a href="#Platform-hasOkHttpOnClasspath" class="headerlink" title="Platform hasOkHttpOnClasspath()"></a>Platform hasOkHttpOnClasspath()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasOkHttpOnClasspath</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      Class.forName(<span class="string">"com.squareup.okhttp.OkHttpClient"</span>);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里为止，<code>RestAdapter</code>就创建好了，接下来跟着例子继续，<code>RestAdapter</code>调用<code>create()</code>方法，创建接口的实现类。</p>
<h3 id="RestAdapter-create"><a href="#RestAdapter-create" class="headerlink" title="RestAdapter create()"></a>RestAdapter create()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; service)</span> </span>&#123;</div><div class="line">    Utils.validateServiceClass(service); <span class="comment">//验证Service是否有效，判断条件：1.这个类是接口  2.该接口不是其它接口的子接口 (接口也可以继承)</span></div><div class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), </div><div class="line">				<span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</div><div class="line">				<span class="keyword">new</span> RestHandler(getMethodInfoCache(service)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里，通过一个动态代理生成了接口的实现类，并在第三个参数里做了一些的操作。</p>
<p>**动态代理的作用：在运行时创建一个实现了一组给定接口的新类。</p>
<p>为什么要用动态代理？因为在编译时无法确定需要实现哪个接口。**</p>
<p>我们慢慢分析，先看这个方法的签名:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * Returns an instance of the dynamically built class for the specified</div><div class="line">   * interfaces. Method invocations on the returned instance are forwarded to</div><div class="line">   * the specified invocation handler. The interfaces must be visible from the</div><div class="line">   * supplied class loader; no duplicates are permitted. All non-public</div><div class="line">   * interfaces must be defined in the same package.</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> loader</div><div class="line">   *            the class loader that will define the proxy class</div><div class="line">   * <span class="doctag">@param</span> interfaces</div><div class="line">   *            an array of &#123;<span class="doctag">@code</span> Class&#125; objects, each one identifying an</div><div class="line">   *            interface thill be implemented by the returned proxy</div><div class="line">   *            object</div><div class="line">   * <span class="doctag">@param</span> invocationHandler</div><div class="line">   *            the invocation handler that handles the dispatched method</div><div class="line">   *            invocations</div><div class="line">   * <span class="doctag">@return</span> a new proxy object that delegates to the handler &#123;<span class="doctag">@code</span> h&#125;</div><div class="line">**/     </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces,</span></span></div><div class="line">			InvocationHandler invocationHandler)<span class="keyword">throws</span> IllegalArgumentException &#123;</div><div class="line">	<span class="keyword">return</span> getProxyClass(loader, interfaces)</div><div class="line">      .getConstructor(InvocationHandler.class)</div><div class="line">      .newInstance(invocationHandler);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法体不管它的错误处理部分，先看它的参数，这个方法有三个参数：</p>
<ol>
<li>loader，没什么可说的，就是一个ClassLoader</li>
<li>interfaces, 传入的接口数组，里面的方法由代理实现</li>
<li>invocationHandler, 方法调用的处理器</li>
</ol>
<p>对于前两个参数默认大家都已经熟悉了，我们看一下最后一个<code>InvocationHandler</code>,这个接口很简单，只定义了一个方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span>;</div></pre></td></tr></table></figure>
<p>举个例子来讲这个方法的含义：</p>
<p>拿经纪人的比喻来说吧，</p>
<p>简单来说，你需要让我做一件事情(要调用原始对象的一个函数)，但是，因为我不很会和别人谈判(作为框架不能和业务逻辑耦合太多)，</p>
<p>那么我就找了一个经纪人，由他来和你谈，当经纪人把前前后后的各种事情帮我弄好之后，</p>
<p>(可以过滤请求，可以让其他对象来完成对原始对象的调用)</p>
<p>我就可以做我的事情(原始对象调用自己的那个函数)，而不用为这些不擅长的事情分心了。</p>
<p>看看<code>invoke()</code>方法注释中的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">    <span class="comment">//do some processing before the method invocation</span></div><div class="line"></div><div class="line">    <span class="comment">//invoke the method</span></div><div class="line">    Object result = method.invoke(proxy, args);</div><div class="line"></div><div class="line">    <span class="comment">//do some processing after the method invocation</span></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在调用方法前后都能加一些你需要做的额外工作，是不是很像我举的例子？还有很重要的一点，你要把原始对象做完的结果返回给调用者。</p>
<p>我们把视线移回到<code>newProxyInstance()</code>的方法体中，在这里先看一下为什么这个方法返回的对象可以被强制转换为传入的接口对象，</p>
<p>就像官方提供的demo一样，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GitHubService service = restAdapter.create(GitHubService.class);</div></pre></td></tr></table></figure>
<p>传入<code>GitHubService</code>，然后最后就可以强制转换为<code>GitHubService</code>对象。</p>
<p>**原因就是在<code>newProxyInstance()</code>这个方法的第二个参数上，我们给这个代理对象提供了一组什么接口，那么我这个代理对象就会实现了这组接口，</p>
<p>这个时候我们当然可以将这个代理对象强制类型转化为这组接口中的任意一个。**</p>
<p>我们传入<code>GitHubService</code>,代理类把这个接口的方法都实现了，自然能转换成<code>GitHubService</code>对象。</p>
<p>在这里第一篇分析就结束了，可以看到<code>new RestHandler(getMethodInfoCache(service))</code>这个方法都没有跟进去，</p>
<p>或许由于局限在Java这门语言的缘故，是因为我觉得<code>Proxy.newProxyInstance()</code>方法很不容易理解，所以到这里结束，</p>
<p>​</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://air.com/2016/01/12/[翻译]使用正确的方式绘制布局/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Air">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Air Little Place">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/12/[翻译]使用正确的方式绘制布局/" itemprop="url">(翻译)使用正确的方式绘制布局</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-12T00:00:00+08:00">
                2016-01-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/01/12/[翻译]使用正确的方式绘制布局/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2016/01/12/[翻译]使用正确的方式绘制布局/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>原文 ： https://possiblemobile.com/2013/05/layout-inflation-as-intended/</code></p>
<h2 id="绘制-inflation，翻译下同-布局-Layout-是在Android的Context中使用的术语，它的作用是解析一个XML布局资源并且把这个资源转换到视图对象的层级-hierarchy-中"><a href="#绘制-inflation，翻译下同-布局-Layout-是在Android的Context中使用的术语，它的作用是解析一个XML布局资源并且把这个资源转换到视图对象的层级-hierarchy-中" class="headerlink" title="绘制(inflation，翻译下同)布局(Layout)是在Android的Context中使用的术语，它的作用是解析一个XML布局资源并且把这个资源转换到视图对象的层级(hierarchy)中"></a>绘制(inflation，翻译下同)布局(Layout)是在Android的Context中使用的术语，它的作用是解析一个XML布局资源并且把这个资源转换到视图对象的层级(hierarchy)中</h2><p>这在Android SDK中很长用，但你会很惊奇的发现有一种错误的方式使用<em>LayoutInflater</em>，并且你的应用可能正在错误的使用它。如果你曾经在你的Android应用中，使用<em>LayoutInflater</em>写过类似下面的代码，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">inflater.inflate(R.layout.my_layout, <span class="keyword">null</span>);</div></pre></td></tr></table></figure>
<p>那么请继续阅读，因为你用错了，我想告诉你为什么你是错的。</p>
<h3 id="了解-LayoutInflater"><a href="#了解-LayoutInflater" class="headerlink" title="了解 LayoutInflater"></a>了解 LayoutInflater</h3><p>首先，我们看一下<em>LayoutInflater</em>是如何工作，对于常见的应用，<em>inflate()</em> 方法有两种可用的方式。</p>
<ol>
<li><code>inflate(int resource, ViewGroup root)</code></li>
<li><code>inflate(int resource, ViewGroup root, boolean attachToRoot)</code></li>
</ol>
<p>第一个参数(resource)指出哪个布局资源想要被绘制。第二个参数是你绘制的资源将会添加到该根视图的层级中(翻译不好，附上原文：The second parameter is the root view of the hierarchy you are inflating the resource to attach to.)。当第三个参数出现的时候，它控制绘制好的视图是否附着到所提供的根视图上。</p>
<p>后两个参数可能会让人困惑。对于这个方法的两个参数版本，<em>LayoutInflater</em>将会自动尝试将绘制好的视图附加到提供的根视图上。然而，系统会做一个检查，防止你给根视图传 <em>null</em> 导致的应用崩溃。</p>
<p>许多开发者使用这种方式，意味着给根视图传<em>null</em>是禁止绘制的视图附着的正确方法；在大部分情况下，甚至没有意识到 <em>inflate()</em> 方法有三个参数的版本。这样做我们同时也禁止了根视图拥有的另外一种很重要的功能——但是我走的太快了，你们可能会跟不上(翻译不好，附上原文：but I’m getting ahead of myself.)。</p>
<h3 id="Android系统的例子"><a href="#Android系统的例子" class="headerlink" title="Android系统的例子"></a>Android系统的例子</h3><p>在系统希望开发者绘制视图的地方，让我们做一些实验。</p>
<p><strong>Adapters</strong>是使用<em>LayoutInflater</em>最常用的地方，通常用在自定义<code>Listview</code>的<em>Adapter</em>中，重载 <em>getView()</em>方法，这个方法有如下的方法签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getView(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</div></pre></td></tr></table></figure>
<p><strong>Fragments</strong>在创建视图的时候也使用<em>LayoutInflater</em>，通过<em>onCreateView()</em>方法；注意它的方法签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</div></pre></td></tr></table></figure>
<p>你是否注意到，每次系统想让你绘制布局的时候，它都会传给你最终要附着到的父<em>ViewGroup</em>？同时在大部分情况下(包括以上两个例子)，在<em>LayoutInflater</em>被允许将绘制好的视图附加到根视图的时候，它将会抛出一个异常。</p>
<p>当我们不应该附着到<em>ViewGroup</em>的时候，为什么我们会需要它？原来，在绘制过程中，父视图是很重要的部分，因为在 XML 文件被绘制的过程中，计算在根元素声明的<em>LayoutParams</em>需要它 。在这里传<em>null</em>相当于告诉系统“抱歉，我不知道需要附着到哪个父视图上”。</p>
<p>这样做的问题是<em>android:layout_xxx</em> 属性总是在父视图的<em>Context</em>中被计算。因此，如果没有父视图的信息，在<strong>XML</strong>树中，所有的根元素声明的<em>LayoutParams</em>将会被丢弃，然后，你将会问“为什么系统忽略我声明的<em>Layout</em>属性，我需要好好检查一下为什么，看看是不是哪里有bug”。</p>
<p>没有了<em>LayoutParams</em>, 最终承载绘制布局的<em>ViewGroup</em>将会生成一个默认的设置给你。 如果你足够幸运(大多数情况下都是)，这些默认的参数和你在 XML中声明的一样——因此遮盖了这里有错误的事实。</p>
<h3 id="应用例子"><a href="#应用例子" class="headerlink" title="应用例子"></a>应用例子</h3><p>因此你说你从没在应用中见过它出现？请看下面的布局，我们用它来绘制 <em>ListView</em> 的行：</p>
<p><strong>R.layout.item_row</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"?android:attr/listPreferredItemHeight"</span></div><div class="line">    <span class="attr">android:gravity</span>=<span class="string">"center_vertical"</span></div><div class="line">    <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/text1"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:paddingRight</span>=<span class="string">"15dp"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"Text1"</span> /&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/text2"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"Text2"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p>我们希望把每行的高度设置为固定的高度，在这种情况下，首选项的高度和当前的主题相关——看起来很合理。</p>
<p>然后，当我们以错误的方式绘制布局的时候</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;</div><div class="line">        convertView = inflate(R.layout.item_row, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> convertView;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们得到的结果看起来像这样：</p>
<p><img src="/img/layout/image1.png" alt=""></p>
<p>我们设置的固定高度出了什么情况？</p>
<p>如果我们替换绘制布局的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;</div><div class="line">        convertView = inflate(R.layout.item_row, parent, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> convertView;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们得到的结果就如我们希望的那样。</p>
<p><img src="/img/layout/Image2.png" alt=""></p>
<h3 id="每个规则都有例外（文中的例外在现在的Android版本已经不存在了，所以这一节就不翻译了）"><a href="#每个规则都有例外（文中的例外在现在的Android版本已经不存在了，所以这一节就不翻译了）" class="headerlink" title="每个规则都有例外（文中的例外在现在的Android版本已经不存在了，所以这一节就不翻译了）"></a>每个规则都有例外（文中的例外在现在的Android版本已经不存在了，所以这一节就不翻译了）</h3><p>所以，下一次你想给 <em>inflate()</em>方法传 <em>null</em>的时候，你需要停下来并问一问你自己“我真的不知道这个视图的根视图是什么吗？(这句话我没有理解作者的意思，就按我觉得翻译了，do I really not know where this view will end up?)”</p>
<p>最后，当第三个参数为true时，你可以使用两个参数版本的<em>inflate()</em> 来省它。当第三个参数为false的时候，你不应该将 <em>null</em> 传给第二个参数来省略它。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Air" />
          <p class="site-author-name" itemprop="name">Air</p>
           
              <p class="site-description motion-element" itemprop="description">Write Something I Want</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yunair" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Air</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://yunair.disqus.com/count.js" async></script>
    

    

  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (search_path.endsWith("json")) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

</body>
</html>
